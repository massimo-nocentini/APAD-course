
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tips an’ Tricks &#8212; APAD course  documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Object Orientation" href="oo.html" />
    <link rel="prev" title="networkx module" href="networkx.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">APAD course</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=massimo-nocentini&repo=APAD-course&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="jupyter-notebooks.html">Jupyter notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="core-concepts.html">Core concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercises.html">Exercises</a></li>
<li class="toctree-l1"><a class="reference internal" href="numpy.html">numpy module</a></li>
<li class="toctree-l1"><a class="reference internal" href="pandas.html">pandas module</a></li>
<li class="toctree-l1"><a class="reference internal" href="matplotlib.html">matplotlib module</a></li>
<li class="toctree-l1"><a class="reference internal" href="networkx.html">networkx module</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tips an’ Tricks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#tips-tricks-and-gotchas">Tips, tricks and gotchas</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-grouping-pattern-avoiding-quadratic-time">A grouping pattern, avoiding <em>quadratic</em> time</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-bunch-pattern">The <em>Bunch</em> pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pythons-list-append-isnt-lisps-cons">Python’s <code class="docutils literal notranslate"><span class="pre">list.append</span></code> isn’t Lisp’s <code class="docutils literal notranslate"><span class="pre">cons</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#hidden-squares-concerning-lists-and-sets">Hidden squares: concerning <code class="docutils literal notranslate"><span class="pre">list</span></code>s and <code class="docutils literal notranslate"><span class="pre">set</span></code>s</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#counting">Counting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#max-permutation">Max permutation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#counting-sort">Counting Sort</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="oo.html">Object Orientation</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="networkx.html" title="previous chapter">networkx module</a></li>
      <li>Next: <a href="oo.html" title="next chapter">Object Orientation</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="networkx.html" title="Previous document">networkx module</a>
        </li>
        <li>
          <a href="oo.html" title="Next document">Object Orientation</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="tips-an-tricks">
<h1>Tips an’ Tricks<a class="headerlink" href="#tips-an-tricks" title="Permalink to this headline">¶</a></h1>
<div class="section" id="tips-tricks-and-gotchas">
<h2>Tips, tricks and gotchas<a class="headerlink" href="#tips-tricks-and-gotchas" title="Permalink to this headline">¶</a></h2>
<p>This lecture addresses some gotchas that could arise in daily
programming; moreover, at the beginning we will introduce some helpful
objects that could make coding easier.</p>
<p>First of all, some imports as usual:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from collections import defaultdict, Counter

import matplotlib.pyplot as plt

%matplotlib inline
plt.rcParams[&#39;figure.figsize&#39;] = (8, 8)
</pre></div>
</div>
<div class="section" id="a-grouping-pattern-avoiding-quadratic-time">
<h3>A grouping pattern, avoiding <em>quadratic</em> time<a class="headerlink" href="#a-grouping-pattern-avoiding-quadratic-time" title="Permalink to this headline">¶</a></h3>
<p>Assume to have two lists that have to be related in some way, namely
using a predicate <span class="math notranslate nohighlight">\(P\)</span>. In the following example we want to build a
list of all pairs (boy,girl) such that their names starts with the same
letter. Here the input:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>girls = [&#39;alice&#39;, &#39;allie&#39;, &#39;bernice&#39;, &#39;brenda&#39;, &#39;clarice&#39;, &#39;cilly&#39;]
boys = [&#39;chris&#39;, &#39;christopher&#39;, &#39;arald&#39;, &#39;arnold&#39;, &#39;bob&#39;]
</pre></div>
</div>
<p>the bad way, quadratic time:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>[(b, g) for b in boys for g in girls if b[0] == g[0]]
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="s1">&#39;chris&#39;</span><span class="p">,</span> <span class="s1">&#39;clarice&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;chris&#39;</span><span class="p">,</span> <span class="s1">&#39;cilly&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;christopher&#39;</span><span class="p">,</span> <span class="s1">&#39;clarice&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;christopher&#39;</span><span class="p">,</span> <span class="s1">&#39;cilly&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;arald&#39;</span><span class="p">,</span> <span class="s1">&#39;alice&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;arald&#39;</span><span class="p">,</span> <span class="s1">&#39;allie&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;arnold&#39;</span><span class="p">,</span> <span class="s1">&#39;alice&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;arnold&#39;</span><span class="p">,</span> <span class="s1">&#39;allie&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;bob&#39;</span><span class="p">,</span> <span class="s1">&#39;bernice&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;bob&#39;</span><span class="p">,</span> <span class="s1">&#39;brenda&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>there is a better approach avoiding quadratic time, toward
<code class="docutils literal notranslate"><span class="pre">`defaultdict</span></code> &lt;<a class="reference external" href="https://docs.python.org/3/library/collections.html#defaultdict-objects">https://docs.python.org/3/library/collections.html#defaultdict-objects</a>&gt;`__:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>letterGirls = {}
for girl in girls:
    letterGirls.setdefault(girl[0], []).append(girl)

[(b, g) for b in boys for g in letterGirls[b[0]]]
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="s1">&#39;chris&#39;</span><span class="p">,</span> <span class="s1">&#39;clarice&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;chris&#39;</span><span class="p">,</span> <span class="s1">&#39;cilly&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;christopher&#39;</span><span class="p">,</span> <span class="s1">&#39;clarice&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;christopher&#39;</span><span class="p">,</span> <span class="s1">&#39;cilly&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;arald&#39;</span><span class="p">,</span> <span class="s1">&#39;alice&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;arald&#39;</span><span class="p">,</span> <span class="s1">&#39;allie&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;arnold&#39;</span><span class="p">,</span> <span class="s1">&#39;alice&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;arnold&#39;</span><span class="p">,</span> <span class="s1">&#39;allie&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;bob&#39;</span><span class="p">,</span> <span class="s1">&#39;bernice&#39;</span><span class="p">),</span>
 <span class="p">(</span><span class="s1">&#39;bob&#39;</span><span class="p">,</span> <span class="s1">&#39;brenda&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>However there is an even better solution, as pointed out in the
<a class="reference external" href="https://docs.python.org/3/library/collections.html#defaultdict-examples">example</a>
subsection of the previous link: use <code class="docutils literal notranslate"><span class="pre">defaultdict</span></code> instead of
repeating call <code class="docutils literal notranslate"><span class="pre">setdefault</span></code> method for each new key. From the official
documentation:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; s = [(&#39;yellow&#39;, 1), (&#39;blue&#39;, 2), (&#39;yellow&#39;, 3), (&#39;blue&#39;, 4), (&#39;red&#39;, 1)]
&gt;&gt;&gt; d = defaultdict(list)
&gt;&gt;&gt; for k, v in s:
...     d[k].append(v)
...
&gt;&gt;&gt; list(d.items())
[(&#39;blue&#39;, [2, 4]), (&#39;red&#39;, [1]), (&#39;yellow&#39;, [1, 3])]
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]),</span> <span class="p">(</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">(</span><span class="s1">&#39;yellow&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])]</span>
</pre></div>
</div>
</div>
<div class="section" id="the-bunch-pattern">
<h3>The <em>Bunch</em> pattern<a class="headerlink" href="#the-bunch-pattern" title="Permalink to this headline">¶</a></h3>
<p>A very good book on algorithms implemented in Python is the one by
Magnus Hetland, <a class="reference external" href="https://www.apress.com/gp/book/9781484200568">https://www.apress.com/gp/book/9781484200568</a>, with the
companion Github repository
<a class="reference external" href="https://github.com/apress/python-algorithms-14">https://github.com/apress/python-algorithms-14</a>.</p>
<p>Hetland, pag. 34, propose the following pattern to build a container of
properties in order to avoid vanilla dict (adjusting from item 4.18 of
Alex Martelli’s <a class="reference external" href="http://shop.oreilly.com/product/9780596007973.do">Python
Cookbook</a>):</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class Bunch(dict):
    def __init__(self, *args, **kwds):
        super(Bunch, self).__init__(*args, **kwds)
        self.__dict__ = self
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; T = Bunch
&gt;&gt;&gt; t = T(left=T(left=&quot;a&quot;, right=&quot;b&quot;), right=T(left=&quot;c&quot;))
&gt;&gt;&gt; t.left
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; t.left.right
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;b&#39;</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; t[&#39;left&#39;][&#39;right&#39;]
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;b&#39;</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; &quot;left&quot; in t.right
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kc">True</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>&quot;right&quot; in t.right
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kc">False</span>
</pre></div>
</div>
<p>However, inheriting from <code class="docutils literal notranslate"><span class="pre">dict</span></code> is discouraged by Alex:</p>
<blockquote>
<div><p>A further tempting but not fully sound alternative is to have the
Bunch class inherit from <code class="docutils literal notranslate"><span class="pre">dict</span></code>, and set attribute access special
methods equal to the item access special methods, as follows:</p>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DictBunch</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="fm">__getattr__</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__getitem__</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__setitem__</span>
    <span class="fm">__delattr__</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="fm">__delitem__</span>
</pre></div>
</div>
<blockquote>
<div><p>One problem with this approach is that, with this definition, an
instance x of <code class="docutils literal notranslate"><span class="pre">DictBunch</span></code> has many attributes it doesn’t really
have, because it inherits all the attributes (methods, actually, but
there’s no significant difference in this context) of <code class="docutils literal notranslate"><span class="pre">dict</span></code>. So,
you can’t meaningfully check <code class="docutils literal notranslate"><span class="pre">hasattr(x,</span> <span class="pre">someattr)</span></code> , as you could
with the classes <code class="docutils literal notranslate"><span class="pre">Bunch</span></code> and <code class="docutils literal notranslate"><span class="pre">EvenSimplerBunch</span></code> (which sets the
dictionary directly, without using <code class="docutils literal notranslate"><span class="pre">update</span></code>) previously shown,
unless you can somehow rule out the value of someattr being any of
several common words such as <code class="docutils literal notranslate"><span class="pre">keys</span></code> , <code class="docutils literal notranslate"><span class="pre">pop</span></code> , and <code class="docutils literal notranslate"><span class="pre">get</span></code>.
Python’s distinction between attributes and items is really a
wellspring of clarity and simplicity. Unfortunately, many newcomers
to Python wrongly believe that it would be better to confuse items
with attributes, generally because of previous experience with
JavaScript and other such languages, in which attributes and items
are regularly confused. But educating newcomers is a much better idea
than promoting item/ attribute confusion.</p>
</div></blockquote>
<p>Alex original definition reads as follows:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>class Bunch(object):
    def __init__(self, **kwds):
        self.__dict__.update(kwds)
</pre></div>
</div>
<p>It is interesting to observe that this idiom has been merged within the
<em>standard library</em>, starting from Python <strong>3.3</strong>, as with the name of
<code class="docutils literal notranslate"><span class="pre">`SimpleNamespace</span></code> &lt;<a class="reference external" href="https://docs.python.org/3/library/types.html#types.SimpleNamespace">https://docs.python.org/3/library/types.html#types.SimpleNamespace</a>&gt;`__:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from types import SimpleNamespace

x, y = 32, 64
point = SimpleNamespace(datum=y, squared=y*y, coord=x)
point
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">namespace</span><span class="p">(</span><span class="n">datum</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="n">coord</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>point.datum, point.squared, point.coord
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">4096</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>[i for i in point]
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">---------------------------------------------------------------------------</span>

<span class="ne">TypeError</span>                                 <span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">)</span>

<span class="o">&lt;</span><span class="n">ipython</span><span class="o">-</span><span class="nb">input</span><span class="o">-</span><span class="mi">18</span><span class="o">-</span><span class="mi">70</span><span class="n">c474fd2112</span><span class="o">&gt;</span> <span class="ow">in</span> <span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span>
<span class="o">----&gt;</span> <span class="mi">1</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">point</span><span class="p">]</span>


<span class="ne">TypeError</span><span class="p">:</span> <span class="s1">&#39;types.SimpleNamespace&#39;</span> <span class="nb">object</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">iterable</span>
</pre></div>
</div>
<p>If you need <code class="docutils literal notranslate"><span class="pre">point</span></code> to be iterable use the structured object
<code class="docutils literal notranslate"><span class="pre">`namedtuple</span></code> &lt;<a class="reference external" href="https://docs.python.org/3/library/collections.html#collections.namedtuple">https://docs.python.org/3/library/collections.html#collections.namedtuple</a>&gt;`__
instead.</p>
</div>
<div class="section" id="pythons-list-append-isnt-lisps-cons">
<h3>Python’s <code class="docutils literal notranslate"><span class="pre">list.append</span></code> isn’t Lisp’s <code class="docutils literal notranslate"><span class="pre">cons</span></code><a class="headerlink" href="#pythons-list-append-isnt-lisps-cons" title="Permalink to this headline">¶</a></h3>
<p>Python <code class="docutils literal notranslate"><span class="pre">list</span></code> objects behave like <code class="docutils literal notranslate"><span class="pre">stack</span></code> objects, such that it is
<em>cheap</em> to <code class="docutils literal notranslate"><span class="pre">append</span></code> and <code class="docutils literal notranslate"><span class="pre">pop</span></code> at the <em>top</em>, which is the <em>right</em>
end. On the other hand, Lisp <code class="docutils literal notranslate"><span class="pre">pair</span></code> objects allows us to <em>easily</em>
<code class="docutils literal notranslate"><span class="pre">cons</span></code> on the <em>beginning</em>, the very <em>opposite</em> direction.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def fast_countdown(count):
    nums = []
    for i in range(count):
        nums.append(i)
    nums.reverse()
    return nums

def slow_countdown(count):
    nums = []
    for i in range(count):
        nums.insert(0, i)
    return nums

def printer(lst, chunk=10):
    print(&quot;{}...{}&quot;.format(&quot; &quot;.join(map(str, lst[:chunk])),
                           &quot; &quot;.join(map(str, lst[-chunk:]))))
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit nums = fast_countdown(10**5)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>5.13 ms ± 118 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit nums = slow_countdown(10**5)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>1.61 s ± 13.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</pre></div>
</div>
<p>Citing Hetland, pag 11:</p>
<blockquote>
<div><p>Python lists aren’t really lists in the traditional computer science
sense of the word, and that explains the puzzle of why append is so
much more efficient than insert . A classical list - a so-called
linked list - is implemented as a series of nodes, each (except for
the last) keeping a reference to the next. The underlying
implementation of Python’s list type is a bit different. Instead of
several separate nodes referencing each other, a list is basically a
single, contiguous slab of memory - what is usually known as an
array. This leads to some important differences from linked lists.
For example, while iterating over the contents of the list is equally
efficient for both kinds (except for some overhead in the linked
list), directly accessing an element at a given index is much more
efficient in an array. This is because the position of the element
can be calculated, and the right memory location can be accessed
directly. In a linked list, however, one would have to traverse the
list from the beginning. The difference we’ve been bumping up
against, though, has to do with insertion. In a linked list, once you
know where you want to insert something, insertion is cheap; it takes
roughly the same amount of time, no matter how many elements the list
contains. That’s not the case with arrays: An insertion would have to
move all elements that are to the right of the insertion point,
possibly even moving all the elements to a larger array, if needed. A
specific solution for appending is to use what’s often called a
dynamic array, or vector. 4 The idea is to allocate an array that is
too big and then to reallocate it in linear time whenever it
overflows. It might seem that this makes the append just as bad as
the insert. In both cases, we risk having to move a large number of
elements. The main difference is that it happens less often with the
append. In fact, if we can ensure that we always move to an array
that is bigger than the last by a fixed percentage (say 20 percent or
even 100 percent), the average cost, amortized over many appends, is
constant.</p>
</div></blockquote>
<div class="section" id="enhance-with-deque-objects">
<h4>enhance with <code class="docutils literal notranslate"><span class="pre">deque</span></code> objects<a class="headerlink" href="#enhance-with-deque-objects" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">deque</span></code> implements <em>FIFO</em> queues: they are as cheap to append to the
right as a normal <code class="docutils literal notranslate"><span class="pre">list</span></code>, but enhance it to <em>cheaply</em> insert on the
<em>front</em> too.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from collections import deque

def enhanced_slow_countdown(count):
    nums = deque()
    for i in range(count):
        nums.appendleft(i)
    return nums
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit nums = enhanced_slow_countdown(10**5)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>5.19 ms ± 159 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</pre></div>
</div>
</div>
</div>
<div class="section" id="hidden-squares-concerning-lists-and-sets">
<h3>Hidden squares: concerning <code class="docutils literal notranslate"><span class="pre">list</span></code>s and <code class="docutils literal notranslate"><span class="pre">set</span></code>s<a class="headerlink" href="#hidden-squares-concerning-lists-and-sets" title="Permalink to this headline">¶</a></h3>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from random import randrange

max_value = 10000
checks = 1000
L = [randrange(max_value) for i in range(checks)]
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit [randrange(max_value) in L for _ in range(checks)]
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>12.7 ms ± 644 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>S = set(L) # convert the list to a set object.

%timeit [randrange(max_value) in S for _ in range(checks)]
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>439 µs ± 31.6 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</pre></div>
</div>
<p>Hetland’s words, pag. 35:</p>
<blockquote>
<div><p>They’re both pretty fast, and it might seem pointless to create a set
from the list—unnecessary work, right? Well, it depends. If you’re
going to do many membership checks, it might pay off, because
membership checks are linear for lists and constant for sets. What
if, for example, you were to gradually add values to a collection and
for each step check whether the value was already added? […] Using a
list would give you quadratic running time, whereas using a set would
be linear. That’s a huge difference. <strong>The lesson is that it’s
important to pick the right built-in data structure for the job.</strong></p>
</div></blockquote>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>lists = [[1, 2], [3, 4, 5], [6]]
sum(lists, [])
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>Hetland, pag.36:</p>
<blockquote>
<div><p>This works, and it even looks rather elegant, but it really isn’t.
You see, under the covers, the sum function doesn’t know all too much
about what you’re summing, and it has to do one addition after
another. That way, you’re right back at the quadratic running time of
the += example for strings. Here’s a better way: Just try timing both
versions. As long as lists is pretty short, there won’t be much
difference, but it shouldn’t take long before the sum version is
thoroughly beaten.</p>
</div></blockquote>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>res = []
for lst in lists:
    res.extend(lst)
res
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>try to do that with more populated lists…</p>
<div class="section" id="concerning-strings">
<h4>concerning <code class="docutils literal notranslate"><span class="pre">string</span></code>s<a class="headerlink" href="#concerning-strings" title="Permalink to this headline">¶</a></h4>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def string_producer(length):
    return &#39;&#39;.join([chr(randrange(ord(&#39;a&#39;), ord(&#39;z&#39;))) for _ in range(length)])
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%%timeit

s = &quot;&quot;
for chunk in string_producer(10**5):
    s += chunk
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>74.4 ms ± 5.29 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
</pre></div>
</div>
<p>maybe some optimization is performed because <code class="docutils literal notranslate"><span class="pre">s</span></code> is a <code class="docutils literal notranslate"><span class="pre">string</span></code>
object.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%%timeit

chunks = []
for chunk in string_producer(10**5):
    chunks.append(chunk)
s = &#39;&#39;.join(chunks)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>61.5 ms ± 1.27 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
</pre></div>
</div>
<p>a better approach using constant <code class="docutils literal notranslate"><span class="pre">append</span></code> to the top</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit s = &#39;&#39;.join(string_producer(10**5))
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>60.1 ms ± 2.26 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
</pre></div>
</div>
<p>maybe a little better since it doesn’t loop with <code class="docutils literal notranslate"><span class="pre">for</span></code> explicitly.</p>
</div>
</div>
</div>
<div class="section" id="counting">
<h2>Counting<a class="headerlink" href="#counting" title="Permalink to this headline">¶</a></h2>
<div class="section" id="max-permutation">
<h3>Max permutation<a class="headerlink" href="#max-permutation" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Eight persons with very particular tastes have bought tickets to the
movies. Some of them are happy with their seats, but most of them are
not. Let’s say each of them has a favorite seat, and you want to find
a way to let them switch seats to make as many people as possible
happy with the result. However, all of them refuse to move to another
seat if they can’t get their favorite.</p>
</div></blockquote>
<p>The following function <code class="docutils literal notranslate"><span class="pre">max_perm</span></code> computes the maximum permutation
that can be applied given a desired one; namely, it produces a new
permutation that moves as many elements as it can, in order to ensure
the <code class="docutils literal notranslate"><span class="pre">one-to-one</span></code> property – no one in the set points outside it, and
each seat (in the set) is pointed to exactly once. It can be seen as a
function that <em>fixes</em> a given permutation according to the required
behavior.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def perm_isomorphism(M, domain):
    iso = dict(enumerate(domain))
    return [iso[M[i]] for i in range(len(M))]

def fix_perm(M, fix):
    return [M[i] if i in fix else i for i in range(len(M))]
</pre></div>
</div>
<p>The following is a naive implementation, recursive but in
<span class="math notranslate nohighlight">\(\mathcal{O}(n^{2})\)</span>, where <span class="math notranslate nohighlight">\(n\)</span> is the permutation length.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def naive_max_perm(M, A=None):
    &#39;&#39;&#39;
    Fix a permutation such that it is one-to-one and maximal, recursively.

    consumes:
    M - a permutation as a list of integers
    A - a set of positions allowed to move

    produces:
    a set `fix` such that makes M maximal, ensuring to be one-to-one
    &#39;&#39;&#39;
    if A is None: A = set(range(len(M))) # init to handle first invocation, all elems can move

    if len(A) == 1: return A # recursion base, unary perm can move, trivial

    B = set(M[i] for i in A) # b in B iff b is desired by someone
    C = A - B # c in C iff c isn&#39;t desired, so discard it
    return naive_max_perm(M, A - C) if C else A # recur with desired position only
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>I = range(8) # the identity permutation
letters = &quot;abcdefgh&quot;
perm_isomorphism(I, letters)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>M = [2, 2, 0, 5, 3, 5, 7, 4]
perm_isomorphism(M, letters)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fix = naive_max_perm(M)
max_M = fix_perm(M, fix)
perm_isomorphism(max_M, letters)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Hetland, pag. 78:</p>
<blockquote>
<div><p>The function <code class="docutils literal notranslate"><span class="pre">naive_max_perm</span></code> receives a set <code class="docutils literal notranslate"><span class="pre">A</span></code> of remaining
people and creates a set <code class="docutils literal notranslate"><span class="pre">B</span></code> of seats that are pointed to. If it
finds an element in <code class="docutils literal notranslate"><span class="pre">A</span></code> that is not in <code class="docutils literal notranslate"><span class="pre">B</span></code>, it removes the
element and solves the remaining problem recursively. Let’s use the
implementation on our example, M = <code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">2,</span> <span class="pre">0,</span> <span class="pre">5,</span> <span class="pre">3,</span> <span class="pre">5,</span> <span class="pre">7,</span> <span class="pre">4]</span></code>:</p>
</div></blockquote>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>naive_max_perm(M)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> {0, 2, 5}



So, a, c, and f can take part in the permutation. The others will
have to sit in nonfavorite seats. The implementation isn’t too bad.
The handy set type lets us manipulate sets with ready-made high-level
operations, rather than having to implement them ourselves. There are
some problems, though. For one thing, we might want an iterative
solution. […] A worse problem, though, is that the algorithm is
quadratic! (Exercise 4-10 asks you to show this.) The most wasteful
operation is the repeated creation of the set B. If we could just
keep track of which chairs are no longer pointed to, we could
eliminate this operation entirely. One way of doing this would be to
keep a count for each element. We could decrement the count for chair
x when a person pointing to x is eliminated, and if x ever got a
count of zero, both person and chair x would be out of the game.
&gt;This idea of reference counting can be useful in general. It is, for
example, a basic component in many systems for garbage collection (a
form of memory management that automatically deallocates objects that
are no longer useful). You’ll see this technique again in the
discussion of topological sorting.

There may be more than one element to be eliminated at any one time,
but we can just put any new ones we come across into a “to-do” list
and deal with them later. If we needed to make sure the elements were
eliminated in the order in which we discover that they’re no longer
useful, we would need to use a first-in, first-out queue such as the
deque class (discussed in Chapter 5). We don’t really care, so we
could use a set, for example, but just appending to and popping from
a list will probably give us quite a bit less overhead. But feel free
to experiment, of course.
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def max_perm(M):
    n = len(M) # How many elements?
    A = set(range(n)) # A = {0, 1, ... , n-1}
    count = Counter(M) # desired positions by frequencies
    Q = deque([i for i in A if not count[i]]) # useless elements
    while Q: # While useless elts. left...
        i = Q.pop() # get one of them
        A.remove(i) # remove it from the maximal permutation
        j = M[i] # get its desired position
        count[j] -= 1 # and release it for someone else
        if not count[j]: # if such position isn&#39;t desired anymore
            Q.appendleft(j) # enqueue such position in order to discard it
    return A
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fix = max_perm(M)
max_M = fix_perm(M, fix)
perm_isomorphism(max_M, letters)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="section" id="counting-sort">
<h3>Counting Sort<a class="headerlink" href="#counting-sort" title="Permalink to this headline">¶</a></h3>
<p>Hetland, pag 85:</p>
<blockquote>
<div><p>By default, I’m just sorting objects based on their values. By
supplying a key function, you can sort by anything you’d like. Note
that the keys must be integers in a limited range. If this range is
<span class="math notranslate nohighlight">\(0\ldots k-1\)</span>, running time is then <span class="math notranslate nohighlight">\(\mathcal{O}(n + k)\)</span>.
(Note that although the common implementation simply counts the
elements and then figures out where to put them in <code class="docutils literal notranslate"><span class="pre">B</span></code>, Python
makes it easy to just build value lists for each key and then
concatenate them.) If several values have the same key, they’ll end
up in the original order with respect to each other. Sorting
algorithms with this property are called <em>stable</em>.</p>
</div></blockquote>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def counting_sort(A, key=None, sort_boundary=None):
    &#39;&#39;&#39;
    Sorts the given collection A in linear time, assuming their elements are hashable.

    This implementation implements a vanilla counting sort, working in linear time respect
    iterable length and spacing between objects. It works best if elements are evenly, namely
    *uniformly* distributed in the domain; on contrast, if they are sparse and concentrated
    near accumulation points, traversing distances between them is time consuming.

    If `sort_boundary` is instantiated to a float within [0,1], then the domain is ordered
    using a classic loglinear algorithm before building the result.
    &#39;&#39;&#39;
    if key is None: key = lambda x: x

    B, C = [], defaultdict(list)
    for x in A:
        C[key(x)].append(x)

    domain = sorted(C)  if sort_boundary and len(C) &lt;= len(A)*sort_boundary \
                        else range(min(C), max(C)+1)
    for k in domain:
        B.extend(C[k])

    return B
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>A = [randrange(50) for i in range(2*10**3)]

assert sorted(A) == counting_sort(A)
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>n, bins, patches = plt.hist(A, 10, facecolor=&#39;green&#39;, alpha=0.5)
plt.xlabel(&#39;elements&#39;); plt.ylabel(&#39;frequencies&#39;); plt.grid(True)
plt.show()
</pre></div>
</div>
<img alt="_images/gotchas_72_0.png" src="_images/gotchas_72_0.png" />
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit counting_sort(A)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>219 µs ± 10.7 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit counting_sort(A, sort_boundary=1)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>206 µs ± 8.96 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>B = ([randrange(50) for i in range(10**3)] +
     [10**4 + randrange(50) for i in range(10**3)])
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>n, bins, patches = plt.hist(B, 100, facecolor=&#39;green&#39;, alpha=0.5)
plt.xlabel(&#39;elements&#39;); plt.ylabel(&#39;frequencies&#39;); plt.grid(True)
plt.show()
</pre></div>
</div>
<img alt="_images/gotchas_76_0.png" src="_images/gotchas_76_0.png" />
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>assert sorted(B) == counting_sort(B)
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit counting_sort(B)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>2.01 ms ± 136 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%timeit counting_sort(B, sort_boundary=1/8)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>247 µs ± 20.4 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)
</pre></div>
</div>
</div>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="networkx.html" title="Previous document">networkx module</a>
        </li>
        <li>
          <a href="oo.html" title="Next document">Object Orientation</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021, Massimo Nocentini.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/gotchas.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>