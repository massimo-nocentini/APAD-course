
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>matplotlib module &#8212; APAD course  documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="networkx module" href="networkx.html" />
    <link rel="prev" title="pandas module" href="pandas.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">APAD course</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=massimo-nocentini&repo=APAD-course&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="jupyter-notebooks.html">Jupyter notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="core-concepts.html">Core concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="exercises.html">Exercises</a></li>
<li class="toctree-l1"><a class="reference internal" href="numpy.html">numpy module</a></li>
<li class="toctree-l1"><a class="reference internal" href="pandas.html">pandas module</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">matplotlib module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#visualization-with-matplotlib">Visualization with Matplotlib</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#importing-matplotlib">Importing Matplotlib</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setting-styles">Setting Styles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#saving-figures-to-file">Saving Figures to File</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#simple-line-plots">Simple Line Plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simple-scatter-plots">Simple Scatter Plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="#visualizing-errors">Visualizing Errors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#density-and-contour-plots">Density and Contour Plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="#histograms-binnings-and-density">Histograms, Binnings, and Density</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#plt-hist2d-two-dimensional-histogram"><code class="docutils literal notranslate"><span class="pre">plt.hist2d</span></code>: Two-dimensional histogram</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plt-hexbin-hexagonal-binnings"><code class="docutils literal notranslate"><span class="pre">plt.hexbin</span></code>: Hexagonal binnings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kernel-density-estimation">Kernel density estimation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#customizing-plot-legends">Customizing Plot Legends</a></li>
<li class="toctree-l2"><a class="reference internal" href="#customizing-colorbars">Customizing Colorbars</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#choosing-the-colormap">Choosing the Colormap</a></li>
<li class="toctree-l3"><a class="reference internal" href="#color-limits-and-extensions">Color limits and extensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#discrete-color-bars">Discrete Color Bars</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#multiple-subplots">Multiple Subplots</a></li>
<li class="toctree-l2"><a class="reference internal" href="#text-and-annotation">Text and Annotation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#customizing-ticks">Customizing Ticks</a></li>
<li class="toctree-l2"><a class="reference internal" href="#customizing-matplotlib-configurations-and-stylesheets">Customizing Matplotlib: Configurations and Stylesheets</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#default-style">Default style</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fivethiryeight-style">FiveThiryEight style</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ggplot">ggplot</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bayesian-methods-for-hackers-style"><em>Bayesian Methods for Hackers</em> style</a></li>
<li class="toctree-l3"><a class="reference internal" href="#seaborn-style">Seaborn style</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#three-dimensional-plotting-in-matplotlib">Three-Dimensional Plotting in Matplotlib</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#example-visualizing-a-mobius-strip">Example: Visualizing a Möbius strip</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#visualization-with-seaborn">Visualization with Seaborn</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#histograms-kde-and-densities">Histograms, KDE, and densities</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pair-plots">Pair plots</a></li>
<li class="toctree-l3"><a class="reference internal" href="#faceted-histograms">Faceted histograms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#factor-plots">Factor plots</a></li>
<li class="toctree-l3"><a class="reference internal" href="#joint-distributions">Joint distributions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bar-plots">Bar plots</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="networkx.html">networkx module</a></li>
<li class="toctree-l1"><a class="reference internal" href="gotchas.html">Tips an’ Tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="oo.html">Object Orientation</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="pandas.html" title="previous chapter">pandas module</a></li>
      <li>Next: <a href="networkx.html" title="next chapter">networkx module</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="pandas.html" title="Previous document">pandas module</a>
        </li>
        <li>
          <a href="networkx.html" title="Next document">networkx module</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="matplotlib-module">
<h1>matplotlib module<a class="headerlink" href="#matplotlib-module" title="Permalink to this headline">¶</a></h1>
<div class="section" id="visualization-with-matplotlib">
<h2>Visualization with Matplotlib<a class="headerlink" href="#visualization-with-matplotlib" title="Permalink to this headline">¶</a></h2>
<p>We’ll now take an in-depth look at the Matplotlib package for
visualization in Python. Matplotlib is a multi-platform data
visualization library built on NumPy arrays, and designed to work with
the broader SciPy stack. It was conceived by John Hunter in 2002,
originally as a patch to IPython for enabling interactive MATLAB-style
plotting via gnuplot from the IPython command line. IPython’s creator,
Fernando Perez, was at the time scrambling to finish his PhD, and let
John know he wouldn’t have time to review the patch for several months.
John took this as a cue to set out on his own, and the Matplotlib
package was born, with version 0.1 released in 2003. It received an
early boost when it was adopted as the plotting package of choice of the
Space Telescope Science Institute (the folks behind the Hubble
Telescope), which financially supported Matplotlib’s development and
greatly expanded its capabilities.</p>
<p>One of Matplotlib’s most important features is its ability to play well
with many operating systems and graphics backends. Matplotlib supports
dozens of backends and output types, which means you can count on it to
work regardless of which operating system you are using or which output
format you wish. This cross-platform, everything-to-everyone approach
has been one of the great strengths of Matplotlib. It has led to a large
user base, which in turn has led to an active developer base and
Matplotlib’s powerful tools and ubiquity within the scientific Python
world.</p>
<p>In recent years, however, the interface and style of Matplotlib have
begun to show their age. Newer tools like ggplot and ggvis in the R
language, along with web visualization toolkits based on D3js and HTML5
canvas, often make Matplotlib feel clunky and old-fashioned. Still, I’m
of the opinion that we cannot ignore Matplotlib’s strength as a
well-tested, cross-platform graphics engine. Recent Matplotlib versions
make it relatively easy to set new global plotting styles (see
<a class="reference external" href="04.11-Settings-and-Stylesheets.ipynb">Customizing Matplotlib: Configurations and Style
Sheets</a>), and people have been
developing new packages that build on its powerful internals to drive
Matplotlib via cleaner, more modern APIs—for example, Seaborn (discussed
in <a class="reference external" href="04.14-Visualization-With-Seaborn.ipynb">Visualization With
Seaborn</a>),
<a class="reference external" href="http://yhat.github.io/ggpy/">ggpy</a>,
<a class="reference external" href="http://holoviews.org/">HoloViews</a>,
<a class="reference external" href="http://altair-viz.github.io/">Altair</a>, and even Pandas itself can be
used as wrappers around Matplotlib’s API. Even with wrappers like these,
it is still often useful to dive into Matplotlib’s syntax to adjust the
final plot output. For this reason, I believe that Matplotlib itself
will remain a vital piece of the data visualization stack, even if new
tools mean the community gradually moves away from using the Matplotlib
API directly.</p>
<div class="section" id="importing-matplotlib">
<h3>Importing Matplotlib<a class="headerlink" href="#importing-matplotlib" title="Permalink to this headline">¶</a></h3>
<p>Just as we use the <code class="docutils literal notranslate"><span class="pre">np</span></code> shorthand for NumPy and the <code class="docutils literal notranslate"><span class="pre">pd</span></code> shorthand
for Pandas, we will use some standard shorthands for Matplotlib imports:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import matplotlib as mpl
import matplotlib.pyplot as plt
</pre></div>
</div>
</div>
<div class="section" id="setting-styles">
<h3>Setting Styles<a class="headerlink" href="#setting-styles" title="Permalink to this headline">¶</a></h3>
<p>We will use the <code class="docutils literal notranslate"><span class="pre">plt.style</span></code> directive to choose appropriate aesthetic
styles for our figures. Here we will set the <code class="docutils literal notranslate"><span class="pre">classic</span></code> style, which
ensures that the plots we create use the classic Matplotlib style:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.style.use(&#39;classic&#39;)
</pre></div>
</div>
<p>Throughout this section, we will adjust this style as needed. Note that
the stylesheets used here are supported as of Matplotlib version 1.5; if
you are using an earlier version of Matplotlib, only the default style
is available. For more information on stylesheets, see <a class="reference external" href="04.11-Settings-and-Stylesheets.ipynb">Customizing
Matplotlib: Configurations and Style
Sheets</a>.</p>
<div class="section" id="general-matplotlib-tips">
<h4>General Matplotlib Tips<a class="headerlink" href="#general-matplotlib-tips" title="Permalink to this headline">¶</a></h4>
<p>Before we dive into the details of creating visualizations with
Matplotlib, there are a few useful things you should know about using
the package.</p>
<div class="section" id="plotting-from-an-ipython-notebook">
<h5>Plotting from an IPython notebook<a class="headerlink" href="#plotting-from-an-ipython-notebook" title="Permalink to this headline">¶</a></h5>
<p>The IPython notebook is a browser-based interactive data analysis tool
that can combine narrative, code, graphics, HTML elements.</p>
<p>Plotting interactively within an IPython notebook can be done with the
<code class="docutils literal notranslate"><span class="pre">%matplotlib</span></code> command, and works in a similar way to the IPython
shell. In the IPython notebook, you also have the option of embedding
graphics directly in the notebook, with two possible options:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">%matplotlib</span> <span class="pre">notebook</span></code> will lead to <em>interactive</em> plots embedded
within the notebook</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">%matplotlib</span> <span class="pre">inline</span></code> will lead to <em>static</em> images of your plot
embedded in the notebook</p></li>
</ul>
<p>For this book, we will generally opt for <code class="docutils literal notranslate"><span class="pre">%matplotlib</span> <span class="pre">inline</span></code>:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline
</pre></div>
</div>
<p>After running this command (it needs to be done only once per
kernel/session), any cell within the notebook that creates a plot will
embed a PNG image of the resulting graphic:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import numpy as np
x = np.linspace(0, 10, 100)

fig = plt.figure()
plt.plot(x, np.sin(x), &#39;-&#39;)
plt.plot(x, np.cos(x), &#39;--&#39;); # pay attention to the last &quot;;&quot; to ignore the Line2D object
</pre></div>
</div>
<img alt="_images/matplotlib_11_0.png" src="_images/matplotlib_11_0.png" />
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>type(_[0])
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">matplotlib</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">Line2D</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="saving-figures-to-file">
<h3>Saving Figures to File<a class="headerlink" href="#saving-figures-to-file" title="Permalink to this headline">¶</a></h3>
<p>One nice feature of Matplotlib is the ability to save figures in a wide
variety of formats. Saving a figure can be done using the <code class="docutils literal notranslate"><span class="pre">savefig()</span></code>
command. For example, to save the previous figure as a PNG file, you can
run this:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig.savefig(&#39;my_figure.png&#39;)
</pre></div>
</div>
<p>We now have a file called <code class="docutils literal notranslate"><span class="pre">my_figure.png</span></code> in the current working
directory:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>!ls -lh my_figure.png
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span><span class="n">rw</span><span class="o">-</span><span class="n">r</span><span class="o">--</span><span class="n">r</span><span class="o">--</span>  <span class="mi">1</span> <span class="n">mn</span>  <span class="n">staff</span>    <span class="mi">26</span><span class="n">K</span> <span class="n">Apr</span>  <span class="mi">8</span> <span class="mi">12</span><span class="p">:</span><span class="mi">10</span> <span class="n">my_figure</span><span class="o">.</span><span class="n">png</span>
</pre></div>
</div>
<p>In <code class="docutils literal notranslate"><span class="pre">savefig()</span></code>, the file format is inferred from the extension of the
given filename. Depending on what backends you have installed, many
different file formats are available. The list of supported file types
can be found for your system by using the following method of the figure
canvas object:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig.canvas.get_supported_filetypes()
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;eps&#39;</span><span class="p">:</span> <span class="s1">&#39;Encapsulated Postscript&#39;</span><span class="p">,</span>
 <span class="s1">&#39;jpg&#39;</span><span class="p">:</span> <span class="s1">&#39;Joint Photographic Experts Group&#39;</span><span class="p">,</span>
 <span class="s1">&#39;jpeg&#39;</span><span class="p">:</span> <span class="s1">&#39;Joint Photographic Experts Group&#39;</span><span class="p">,</span>
 <span class="s1">&#39;pdf&#39;</span><span class="p">:</span> <span class="s1">&#39;Portable Document Format&#39;</span><span class="p">,</span>
 <span class="s1">&#39;pgf&#39;</span><span class="p">:</span> <span class="s1">&#39;PGF code for LaTeX&#39;</span><span class="p">,</span>
 <span class="s1">&#39;png&#39;</span><span class="p">:</span> <span class="s1">&#39;Portable Network Graphics&#39;</span><span class="p">,</span>
 <span class="s1">&#39;ps&#39;</span><span class="p">:</span> <span class="s1">&#39;Postscript&#39;</span><span class="p">,</span>
 <span class="s1">&#39;raw&#39;</span><span class="p">:</span> <span class="s1">&#39;Raw RGBA bitmap&#39;</span><span class="p">,</span>
 <span class="s1">&#39;rgba&#39;</span><span class="p">:</span> <span class="s1">&#39;Raw RGBA bitmap&#39;</span><span class="p">,</span>
 <span class="s1">&#39;svg&#39;</span><span class="p">:</span> <span class="s1">&#39;Scalable Vector Graphics&#39;</span><span class="p">,</span>
 <span class="s1">&#39;svgz&#39;</span><span class="p">:</span> <span class="s1">&#39;Scalable Vector Graphics&#39;</span><span class="p">,</span>
 <span class="s1">&#39;tif&#39;</span><span class="p">:</span> <span class="s1">&#39;Tagged Image File Format&#39;</span><span class="p">,</span>
 <span class="s1">&#39;tiff&#39;</span><span class="p">:</span> <span class="s1">&#39;Tagged Image File Format&#39;</span><span class="p">}</span>
</pre></div>
</div>
<div class="section" id="two-interfaces-for-the-price-of-one">
<h4>Two Interfaces for the Price of One<a class="headerlink" href="#two-interfaces-for-the-price-of-one" title="Permalink to this headline">¶</a></h4>
<p>A potentially confusing feature of Matplotlib is its dual interfaces: a
convenient MATLAB-style state-based interface, and a more powerful
object-oriented interface. We’ll quickly highlight the differences
between the two here.</p>
<div class="section" id="matlab-style-interface">
<h5>MATLAB-style Interface<a class="headerlink" href="#matlab-style-interface" title="Permalink to this headline">¶</a></h5>
<p>Matplotlib was originally written as a Python alternative for MATLAB
users, and much of its syntax reflects that fact. The MATLAB-style tools
are contained in the pyplot (<code class="docutils literal notranslate"><span class="pre">plt</span></code>) interface. For example, the
following code will probably look quite familiar to MATLAB users:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = plt.figure()  # create a plot figure

# create the first of two panels and set current axis
plt.subplot(2, 1, 1) # (rows, columns, panel number)
plt.plot(x, np.sin(x))

# create the second panel and set current axis
plt.subplot(2, 1, 2)
plt.plot(x, np.cos(x), &#39;--&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_21_0.png" src="_images/matplotlib_21_0.png" />
</div>
<div class="section" id="object-oriented-interface">
<h5>Object-oriented interface<a class="headerlink" href="#object-oriented-interface" title="Permalink to this headline">¶</a></h5>
<p>The object-oriented interface is available for these more complicated
situations, and for when you want more control over your figure. Rather
than depending on some notion of an “active” figure or axes, in the
object-oriented interface the plotting functions are <em>methods</em> of
explicit <code class="docutils literal notranslate"><span class="pre">Figure</span></code> and <code class="docutils literal notranslate"><span class="pre">Axes</span></code> objects. To re-create the previous plot
using this style of plotting, you might do the following:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># First create a grid of plots
# ax will be an array of two Axes objects
fig, ax = plt.subplots(2)

# Call plot() method on the appropriate object
ax[0].plot(x, np.sin(x))
ax[1].plot(x, np.cos(x), &#39;--&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_23_0.png" src="_images/matplotlib_23_0.png" />
</div>
</div>
</div>
</div>
<div class="section" id="simple-line-plots">
<h2>Simple Line Plots<a class="headerlink" href="#simple-line-plots" title="Permalink to this headline">¶</a></h2>
<p>Perhaps the simplest of all plots is the visualization of a single
function <span class="math notranslate nohighlight">\(y = f(x)\)</span>. Here we will take a first look at creating a
simple plot of this type. As with all the following sections, we’ll
start by setting up the notebook for plotting and importing the packages
we will use:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline
import matplotlib.pyplot as plt
plt.style.use(&#39;seaborn-whitegrid&#39;)
import numpy as np
</pre></div>
</div>
<p>For all Matplotlib plots, we start by creating a figure and an axes. In
their simplest form, a figure and axes can be created as follows:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = plt.figure()
ax = plt.axes()
</pre></div>
</div>
<img alt="_images/matplotlib_27_0.png" src="_images/matplotlib_27_0.png" />
<p>In Matplotlib, the <em>figure</em> (an instance of the class <code class="docutils literal notranslate"><span class="pre">plt.Figure</span></code>)
can be thought of as a single container that contains all the objects
representing axes, graphics, text, and labels. The <em>axes</em> (an instance
of the class <code class="docutils literal notranslate"><span class="pre">plt.Axes</span></code>) is what we see above: a bounding box with
ticks and labels, which will eventually contain the plot elements that
make up our visualization. Throughout this book, we’ll commonly use the
variable name <code class="docutils literal notranslate"><span class="pre">fig</span></code> to refer to a figure instance, and <code class="docutils literal notranslate"><span class="pre">ax</span></code> to refer
to an axes instance or group of axes instances.</p>
<p>Once we have created an axes, we can use the <code class="docutils literal notranslate"><span class="pre">ax.plot</span></code> function to
plot some data. Let’s start with a simple sinusoid:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = plt.figure()
ax = plt.axes()

x = np.linspace(0, 10, 1000)
ax.plot(x, np.sin(x));
</pre></div>
</div>
<img alt="_images/matplotlib_30_0.png" src="_images/matplotlib_30_0.png" />
<p>Alternatively, we can use the pylab interface and let the figure and
axes be created for us in the background:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, np.sin(x));
</pre></div>
</div>
<img alt="_images/matplotlib_32_0.png" src="_images/matplotlib_32_0.png" />
<p>If we want to create a single figure with multiple lines, we can simply
call the <code class="docutils literal notranslate"><span class="pre">plot</span></code> function multiple times:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, np.sin(x))
plt.plot(x, np.cos(x), &#39;--&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_34_0.png" src="_images/matplotlib_34_0.png" />
<p>The first adjustment you might wish to make to a plot is to control the
line colors and styles. The <code class="docutils literal notranslate"><span class="pre">plt.plot()</span></code> function takes additional
arguments that can be used to specify these. To adjust the color, you
can use the <code class="docutils literal notranslate"><span class="pre">color</span></code> keyword, which accepts a string argument
representing virtually any imaginable color.</p>
<p>The color can be specified in a variety of ways (If no color is
specified, Matplotlib will automatically cycle through a set of default
colors for multiple lines):</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, np.sin(x - 0), &#39;--&#39;, color=&#39;blue&#39;)        # specify color by name
plt.plot(x, np.sin(x - 1), color=&#39;g&#39;)           # short color code (rgbcmyk)
plt.plot(x, np.sin(x - 2), color=&#39;0.75&#39;)        # Grayscale between 0 and 1
plt.plot(x, np.sin(x - 3), color=&#39;#FFDD44&#39;)     # Hex code (RRGGBB from 00 to FF)
plt.plot(x, np.sin(x - 4), color=(1.0,0.2,0.3)) # RGB tuple, values 0 to 1
plt.plot(x, np.sin(x - 5), color=&#39;chartreuse&#39;); # all HTML color names supported
</pre></div>
</div>
<img alt="_images/matplotlib_37_0.png" src="_images/matplotlib_37_0.png" />
<p>Similarly, the line style can be adjusted using the <code class="docutils literal notranslate"><span class="pre">linestyle</span></code>
keyword:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, x + 0, linestyle=&#39;solid&#39;)
plt.plot(x, x + 1, linestyle=&#39;dashed&#39;) # &#39;--&#39;
plt.plot(x, x + 2, linestyle=&#39;dashdot&#39;)
plt.plot(x, x + 3, linestyle=&#39;dotted&#39;);

# For short, you can use the following codes:
plt.plot(x, x + 4, linestyle=&#39;-&#39;)  # solid
plt.plot(x, x + 5, linestyle=&#39;--&#39;) # dashed
plt.plot(x, x + 6, linestyle=&#39;-.&#39;) # dashdot
plt.plot(x, x + 7, linestyle=&#39;:&#39;);  # dotted
</pre></div>
</div>
<img alt="_images/matplotlib_39_0.png" src="_images/matplotlib_39_0.png" />
<p>If you would like to be extremely terse, these <code class="docutils literal notranslate"><span class="pre">linestyle</span></code> and
<code class="docutils literal notranslate"><span class="pre">color</span></code> codes can be combined into a single non-keyword argument to
the <code class="docutils literal notranslate"><span class="pre">plt.plot()</span></code> function:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, x + 0, &#39;-g&#39;)  # solid green
plt.plot(x, x + 1, &#39;--c&#39;) # dashed cyan
plt.plot(x, x + 2, &#39;-.k&#39;) # dashdot black
plt.plot(x, x + 3, &#39;:r&#39;);  # dotted red
</pre></div>
</div>
<img alt="_images/matplotlib_41_0.png" src="_images/matplotlib_41_0.png" />
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import this
</pre></div>
</div>
<pre class="literal-block">The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than <em>right</em> now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!</pre>
<p>Matplotlib does a decent job of choosing default axes limits for your
plot, but sometimes it’s nice to have finer control. The most basic way
to adjust axis limits is to use the <code class="docutils literal notranslate"><span class="pre">plt.xlim()</span></code> and <code class="docutils literal notranslate"><span class="pre">plt.ylim()</span></code>
methods:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, np.sin(x))

plt.xlim(-1, 11)
plt.ylim(-1.5, 1.5);
</pre></div>
</div>
<img alt="_images/matplotlib_44_0.png" src="_images/matplotlib_44_0.png" />
<p>If for some reason you’d like either axis to be displayed in reverse,
you can simply reverse the order of the arguments:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, np.sin(x))

plt.xlim(10, 0)
plt.ylim(1.2, -1.2);
</pre></div>
</div>
<img alt="_images/matplotlib_46_0.png" src="_images/matplotlib_46_0.png" />
<p>A useful related method is <code class="docutils literal notranslate"><span class="pre">plt.axis()</span></code> (note here the potential
confusion between <em>axes</em> with an <em>e</em>, and <em>axis</em> with an <em>i</em>). The
<code class="docutils literal notranslate"><span class="pre">plt.axis()</span></code> method allows you to set the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> limits with
a single call, by passing a list which specifies
<code class="docutils literal notranslate"><span class="pre">[xmin,</span> <span class="pre">xmax,</span> <span class="pre">ymin,</span> <span class="pre">ymax]</span></code>:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, np.sin(x))
plt.axis([-1, 11, -1.5, 1.5]);
</pre></div>
</div>
<img alt="_images/matplotlib_48_0.png" src="_images/matplotlib_48_0.png" />
<p>The <code class="docutils literal notranslate"><span class="pre">plt.axis()</span></code> method goes even beyond this, allowing you to do
things like automatically tighten the bounds around the current plot:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, np.sin(x))
plt.axis(&#39;tight&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_50_0.png" src="_images/matplotlib_50_0.png" />
<p>It allows even higher-level specifications, such as ensuring an equal
aspect ratio so that on your screen, one unit in <code class="docutils literal notranslate"><span class="pre">x</span></code> is equal to one
unit in <code class="docutils literal notranslate"><span class="pre">y</span></code>:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, np.sin(x))
plt.axis(&#39;equal&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_52_0.png" src="_images/matplotlib_52_0.png" />
<p>As the last piece of this section, we’ll briefly look at the labeling of
plots: titles, axis labels, and simple legends.</p>
<p>Titles and axis labels are the simplest such labels—there are methods
that can be used to quickly set them:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, np.sin(x))
plt.title(&quot;A Sine Curve&quot;)
plt.xlabel(&quot;x&quot;)
plt.ylabel(&quot;sin(x)&quot;);
</pre></div>
</div>
<img alt="_images/matplotlib_54_0.png" src="_images/matplotlib_54_0.png" />
<p>When multiple lines are being shown within a single axes, it can be
useful to create a plot legend that labels each line type. Again,
Matplotlib has a built-in way of quickly creating such a legend. It is
done via the (you guessed it) <code class="docutils literal notranslate"><span class="pre">plt.legend()</span></code> method. Though there are
several valid ways of using this, I find it easiest to specify the label
of each line using the <code class="docutils literal notranslate"><span class="pre">label</span></code> keyword of the plot function:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, np.sin(x), &#39;-g&#39;, label=&#39;sin(x)&#39;)
plt.plot(x, np.cos(x), &#39;:b&#39;, label=&#39;cos(x)&#39;)
plt.axis(&#39;equal&#39;)

plt.legend();
</pre></div>
</div>
<img alt="_images/matplotlib_56_0.png" src="_images/matplotlib_56_0.png" />
<p>While most <code class="docutils literal notranslate"><span class="pre">plt</span></code> functions translate directly to <code class="docutils literal notranslate"><span class="pre">ax</span></code> methods (such
as <code class="docutils literal notranslate"><span class="pre">plt.plot()</span></code> → <code class="docutils literal notranslate"><span class="pre">ax.plot()</span></code>, <code class="docutils literal notranslate"><span class="pre">plt.legend()</span></code> → <code class="docutils literal notranslate"><span class="pre">ax.legend()</span></code>,
etc.), this is not the case for all commands. In particular, functions
to set limits, labels, and titles are slightly modified. For
transitioning between MATLAB-style functions and object-oriented
methods, make the following changes:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">plt.xlabel()</span></code> → <code class="docutils literal notranslate"><span class="pre">ax.set_xlabel()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">plt.ylabel()</span></code> → <code class="docutils literal notranslate"><span class="pre">ax.set_ylabel()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">plt.xlim()</span></code> → <code class="docutils literal notranslate"><span class="pre">ax.set_xlim()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">plt.ylim()</span></code> → <code class="docutils literal notranslate"><span class="pre">ax.set_ylim()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">plt.title()</span></code> → <code class="docutils literal notranslate"><span class="pre">ax.set_title()</span></code></p></li>
</ul>
<p>In the object-oriented interface to plotting, rather than calling these
functions individually, it is often more convenient to use the
<code class="docutils literal notranslate"><span class="pre">ax.set()</span></code> method to set all these properties at once:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax = plt.axes()
ax.plot(x, np.sin(x))
ax.set(xlim=(0, 10), ylim=(-2, 2), xlabel=&#39;x&#39;, ylabel=&#39;sin(x)&#39;, title=&#39;A Simple Plot&#39;); # focus on metadata only
</pre></div>
</div>
<img alt="_images/matplotlib_58_0.png" src="_images/matplotlib_58_0.png" />
</div>
<div class="section" id="simple-scatter-plots">
<h2>Simple Scatter Plots<a class="headerlink" href="#simple-scatter-plots" title="Permalink to this headline">¶</a></h2>
<p>Another commonly used plot type is the simple scatter plot, a close
cousin of the line plot. Instead of points being joined by line
segments, here the points are represented individually with a dot,
circle, or other shape. We’ll start by setting up the notebook for
plotting and importing the functions we will use:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline
import matplotlib.pyplot as plt
plt.style.use(&#39;seaborn-whitegrid&#39;)
import numpy as np
</pre></div>
</div>
<p>In the previous section we looked at <code class="docutils literal notranslate"><span class="pre">plt.plot</span></code>/<code class="docutils literal notranslate"><span class="pre">ax.plot</span></code> to produce
line plots. It turns out that this same function can produce scatter
plots as well:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x = np.linspace(0, 10, 30)
y = np.sin(x)

plt.plot(x, y, &#39;o&#39;, color=&#39;black&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_62_0.png" src="_images/matplotlib_62_0.png" />
<p>The third argument in the function call is a character that represents
the type of symbol used for the plotting. Just as you can specify
options such as <code class="docutils literal notranslate"><span class="pre">'-'</span></code>, <code class="docutils literal notranslate"><span class="pre">'--'</span></code> to control the line style, the marker
style has its own set of short string codes. The full list of available
symbols can be seen in the documentation of <code class="docutils literal notranslate"><span class="pre">plt.plot</span></code>, or in
Matplotlib’s online documentation. Most of the possibilities are fairly
intuitive, and we’ll show a number of the more common ones here:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>rng = np.random.RandomState(0)
for marker in [&#39;o&#39;, &#39;.&#39;, &#39;,&#39;, &#39;x&#39;, &#39;+&#39;, &#39;v&#39;, &#39;^&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;s&#39;, &#39;d&#39;]:
    plt.plot(rng.rand(5), rng.rand(5), marker, label=&quot;marker=&#39;{0}&#39;&quot;.format(marker))
plt.legend(numpoints=1)
plt.xlim(0, 1.8);
</pre></div>
</div>
<img alt="_images/matplotlib_64_0.png" src="_images/matplotlib_64_0.png" />
<p>For even more possibilities, these character codes can be used together
with line and color codes to plot points along with a line connecting
them:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, y, &#39;-ok&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_66_0.png" src="_images/matplotlib_66_0.png" />
<p>Additional keyword arguments to <code class="docutils literal notranslate"><span class="pre">plt.plot</span></code> specify a wide range of
properties of the lines and markers:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, y, &#39;-p&#39;, color=&#39;gray&#39;,
         markersize=15, linewidth=4,
         markerfacecolor=&#39;white&#39;,
         markeredgecolor=&#39;gray&#39;,
         markeredgewidth=2)
plt.ylim(-1.2, 1.2);
</pre></div>
</div>
<img alt="_images/matplotlib_68_0.png" src="_images/matplotlib_68_0.png" />
<p>A second, more powerful method of creating scatter plots is the
<code class="docutils literal notranslate"><span class="pre">plt.scatter</span></code> function, which can be used very similarly to the
<code class="docutils literal notranslate"><span class="pre">plt.plot</span></code> function:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.scatter(x, y, marker=&#39;o&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_70_0.png" src="_images/matplotlib_70_0.png" />
<p>The primary difference of <code class="docutils literal notranslate"><span class="pre">plt.scatter</span></code> from <code class="docutils literal notranslate"><span class="pre">plt.plot</span></code> is that it
can be used to create scatter plots where the properties of each
individual point (size, face color, edge color, etc.) can be
individually controlled or mapped to data.</p>
<p>Let’s show this by creating a random scatter plot with points of many
colors and sizes. In order to better see the overlapping results, we’ll
also use the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> keyword to adjust the transparency level:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>rng = np.random.RandomState(0)
x = rng.randn(100)
y = rng.randn(100)
colors = rng.rand(100)
sizes = 1000 * rng.rand(100)

plt.scatter(x, y, c=colors, s=sizes, alpha=0.3, cmap=&#39;viridis&#39;)
plt.colorbar();  # show color scale. In parallel with `plt.legend()`
</pre></div>
</div>
<img alt="_images/matplotlib_73_0.png" src="_images/matplotlib_73_0.png" />
<p>Notice that the color argument is automatically mapped to a color scale
(shown here by the <code class="docutils literal notranslate"><span class="pre">colorbar()</span></code> command), and that the size argument
is given in pixels. In this way, the color and size of points can be
used to convey information in the visualization, in order to visualize
multidimensional data.</p>
<p>For example, we might use the Iris data from Scikit-Learn, where each
sample is one of three types of flowers that has had the size of its
petals and sepals carefully measured:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from sklearn.datasets import load_iris
iris = load_iris()
features = iris.data.T

plt.scatter(features[0], features[1], alpha=0.2, s=100*features[3], c=iris.target, cmap=&#39;viridis&#39;)
plt.xlabel(iris.feature_names[0])
plt.ylabel(iris.feature_names[1]);
</pre></div>
</div>
<img alt="_images/matplotlib_76_0.png" src="_images/matplotlib_76_0.png" />
<p>Aside from the different features available in <code class="docutils literal notranslate"><span class="pre">plt.plot</span></code> and
<code class="docutils literal notranslate"><span class="pre">plt.scatter</span></code>, why might you choose to use one over the other? While
it doesn’t matter as much for small amounts of data, as datasets get
larger than a few thousand points, <code class="docutils literal notranslate"><span class="pre">plt.plot</span></code> can be noticeably more
efficient than <code class="docutils literal notranslate"><span class="pre">plt.scatter</span></code>. The reason is that <code class="docutils literal notranslate"><span class="pre">plt.scatter</span></code> has
the capability to render a different size and/or color for each point,
so the renderer must do the extra work of constructing each point
individually. In <code class="docutils literal notranslate"><span class="pre">plt.plot</span></code>, on the other hand, the points are always
essentially clones of each other, so the work of determining the
appearance of the points is done only once for the entire set of data.
For large datasets, the difference between these two can lead to vastly
different performance, and for this reason, <code class="docutils literal notranslate"><span class="pre">plt.plot</span></code> should be
preferred over <code class="docutils literal notranslate"><span class="pre">plt.scatter</span></code> for large datasets.</p>
</div>
<div class="section" id="visualizing-errors">
<h2>Visualizing Errors<a class="headerlink" href="#visualizing-errors" title="Permalink to this headline">¶</a></h2>
<p>For any scientific measurement, accurate accounting for errors is nearly
as important, if not more important, than accurate reporting of the
number itself. For example, imagine that I am using some astrophysical
observations to estimate the Hubble Constant, the local measurement of
the expansion rate of the Universe. I know that the current literature
suggests a value of around 71 (km/s)/Mpc, and I measure a value of 74
(km/s)/Mpc with my method. Are the values consistent? The only correct
answer, given this information, is this: there is no way to know.</p>
<p>Suppose I augment this information with reported uncertainties: the
current literature suggests a value of around 71 <span class="math notranslate nohighlight">\(\pm\)</span> 2.5
(km/s)/Mpc, and my method has measured a value of 74 <span class="math notranslate nohighlight">\(\pm\)</span> 5
(km/s)/Mpc. Now are the values consistent? That is a question that can
be quantitatively answered.</p>
<p>In visualization of data and results, showing these errors effectively
can make a plot convey much more complete information.</p>
<p>A basic errorbar can be created with a single Matplotlib function call:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline
import matplotlib.pyplot as plt
plt.style.use(&#39;seaborn-whitegrid&#39;)
import numpy as np
</pre></div>
</div>
<p>Here the <code class="docutils literal notranslate"><span class="pre">fmt</span></code> is a format code controlling the appearance of lines
and points, and has the same syntax as the shorthand used in
<code class="docutils literal notranslate"><span class="pre">plt.plot</span></code>.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x = np.linspace(0, 10, 50)
dy = 0.8
y = np.sin(x) + dy * np.random.randn(50)

plt.errorbar(x, y, yerr=dy, fmt=&#39;.k&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_82_0.png" src="_images/matplotlib_82_0.png" />
<p>In addition to these basic options, the <code class="docutils literal notranslate"><span class="pre">errorbar</span></code> function has many
options to fine-tune the outputs. Using these additional options you can
easily customize the aesthetics of your errorbar plot. I often find it
helpful, especially in crowded plots, to make the errorbars lighter than
the points themselves:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.errorbar(x, y, yerr=dy, fmt=&#39;o&#39;, color=&#39;black&#39;, ecolor=&#39;lightgray&#39;, elinewidth=3, capsize=0);
</pre></div>
</div>
<img alt="_images/matplotlib_84_0.png" src="_images/matplotlib_84_0.png" />
</div>
<div class="section" id="density-and-contour-plots">
<h2>Density and Contour Plots<a class="headerlink" href="#density-and-contour-plots" title="Permalink to this headline">¶</a></h2>
<p>Sometimes it is useful to display three-dimensional data in two
dimensions using contours or color-coded regions. There are three
Matplotlib functions that can be helpful for this task: <code class="docutils literal notranslate"><span class="pre">plt.contour</span></code>
for contour plots, <code class="docutils literal notranslate"><span class="pre">plt.contourf</span></code> for filled contour plots, and
<code class="docutils literal notranslate"><span class="pre">plt.imshow</span></code> for showing images. This section looks at several
examples of using these. We’ll start by setting up the notebook for
plotting and importing the functions we will use:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline
import matplotlib.pyplot as plt
plt.style.use(&#39;seaborn-white&#39;)
import numpy as np
</pre></div>
</div>
<p>We’ll start by demonstrating a contour plot using a function
<span class="math notranslate nohighlight">\(z = f(x, y)\)</span>, using the following particular choice for <span class="math notranslate nohighlight">\(f\)</span>
(we’ve seen this before in <a class="reference external" href="02.05-Computation-on-arrays-broadcasting.ipynb">Computation on Arrays:
Broadcasting</a>, when
we used it as a motivating example for array broadcasting):</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def f(x, y):
    return np.sin(x) ** 10 + np.cos(10 + y * x) * np.cos(x)
</pre></div>
</div>
<p>A contour plot can be created with the <code class="docutils literal notranslate"><span class="pre">plt.contour</span></code> function. It
takes three arguments: a grid of <em>x</em> values, a grid of <em>y</em> values, and a
grid of <em>z</em> values. The <em>x</em> and <em>y</em> values represent positions on the
plot, and the <em>z</em> values will be represented by the contour levels.
Perhaps the most straightforward way to prepare such data is to use the
<code class="docutils literal notranslate"><span class="pre">np.meshgrid</span></code> function, which builds two-dimensional grids from
one-dimensional arrays:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x = np.linspace(0, 5, 50)
y = np.linspace(0, 5, 40)

X, Y = np.meshgrid(x, y)
Z = f(X, Y)
</pre></div>
</div>
<p>Now let’s look at this with a standard line-only contour plot:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.contour(X, Y, Z, colors=&#39;black&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_92_0.png" src="_images/matplotlib_92_0.png" />
<p>Notice that by default when a single color is used, negative values are
represented by dashed lines, and positive values by solid lines.</p>
<p>Alternatively, the lines can be color-coded by specifying a colormap
with the <code class="docutils literal notranslate"><span class="pre">cmap</span></code> argument. Here, we’ll also specify that we want more
lines to be drawn—20 equally spaced intervals within the data range:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.contour(X, Y, Z, 20, cmap=&#39;RdGy&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_95_0.png" src="_images/matplotlib_95_0.png" />
<p>Here we chose the <code class="docutils literal notranslate"><span class="pre">RdGy</span></code> (short for <em>Red-Gray</em>) colormap, which is a
good choice for centered data. Matplotlib has a wide range of colormaps
available, which you can easily browse in IPython by doing a tab
completion on the <code class="docutils literal notranslate"><span class="pre">plt.cm</span></code> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.&lt;</span><span class="n">TAB</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Our plot is looking nicer, but the spaces between the lines may be a bit
distracting. We can change this by switching to a filled contour plot
using the <code class="docutils literal notranslate"><span class="pre">plt.contourf()</span></code> function (notice the <code class="docutils literal notranslate"><span class="pre">f</span></code> at the end),
which uses largely the same syntax as <code class="docutils literal notranslate"><span class="pre">plt.contour()</span></code>.</p>
<p>Additionally, we’ll add a <code class="docutils literal notranslate"><span class="pre">plt.colorbar()</span></code> command, which
automatically creates an additional axis with labeled color information
for the plot:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.contourf(X, Y, Z, 20, cmap=&#39;RdGy&#39;)
plt.colorbar(); # The colorbar makes it clear that the black regions
                # are &quot;peaks,&quot; while the red regions are &quot;valleys.&quot;
</pre></div>
</div>
<img alt="_images/matplotlib_98_0.png" src="_images/matplotlib_98_0.png" />
<p>One potential issue with this plot is that it is a bit “splotchy.” That
is, the color steps are discrete rather than continuous, which is not
always what is desired. This could be remedied by setting the number of
contours to a very high number, but this results in a rather inefficient
plot: Matplotlib must render a new polygon for each step in the level. A
better way to handle this is to use the <code class="docutils literal notranslate"><span class="pre">plt.imshow()</span></code> function, which
interprets a two-dimensional grid of data as an image. The following
code shows this:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.imshow(Z, extent=[0, 5, 0, 5], origin=&#39;lower&#39;, cmap=&#39;RdGy&#39;)
plt.colorbar()
plt.axis(aspect=&#39;image&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_100_0.png" src="_images/matplotlib_100_0.png" />
<p>There are a few potential gotchas with <code class="docutils literal notranslate"><span class="pre">imshow()</span></code>, however:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">plt.imshow()</span></code> doesn’t accept an <em>x</em> and <em>y</em> grid, so you must
manually specify the <em>extent</em> [<em>xmin</em>, <em>xmax</em>, <em>ymin</em>, <em>ymax</em>] of the
image on the plot.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">plt.imshow()</span></code> by default follows the standard image array
definition where the origin is in the upper left, not in the lower
left as in most contour plots. This must be changed when showing
gridded data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">plt.imshow()</span></code> will automatically adjust the axis aspect ratio to
match the input data; this can be changed by setting, for example,
<code class="docutils literal notranslate"><span class="pre">plt.axis(aspect='image')</span></code> to make <em>x</em> and <em>y</em> units match.</p></li>
</ul>
<p>Finally, it can sometimes be useful to combine contour plots and image
plots. For example, here we’ll use a partially transparent background
image (with transparency set via the <code class="docutils literal notranslate"><span class="pre">alpha</span></code> parameter) and overplot
contours with labels on the contours themselves (using the
<code class="docutils literal notranslate"><span class="pre">plt.clabel()</span></code> function):</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>contours = plt.contour(X, Y, Z, 3, colors=&#39;black&#39;)
plt.clabel(contours, inline=True, fontsize=8)

plt.imshow(Z, extent=[0, 5, 0, 5], origin=&#39;lower&#39;, cmap=&#39;RdGy&#39;, alpha=0.5)
plt.colorbar();
</pre></div>
</div>
<img alt="_images/matplotlib_103_0.png" src="_images/matplotlib_103_0.png" />
</div>
<div class="section" id="histograms-binnings-and-density">
<h2>Histograms, Binnings, and Density<a class="headerlink" href="#histograms-binnings-and-density" title="Permalink to this headline">¶</a></h2>
<p>A simple histogram can be a great first step in understanding a dataset.
Earlier, we saw a preview of Matplotlib’s histogram function (see
<a class="reference external" href="02.06-Boolean-Arrays-and-Masks.ipynb">Comparisons, Masks, and Boolean
Logic</a>), which creates a basic
histogram in one line, once the normal boiler-plate imports are done:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
plt.style.use(&#39;seaborn-white&#39;)
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>data = np.random.randn(1000)
plt.hist(data);
</pre></div>
</div>
<img alt="_images/matplotlib_106_0.png" src="_images/matplotlib_106_0.png" />
<p>The <code class="docutils literal notranslate"><span class="pre">hist()</span></code> function has many options to tune both the calculation
and the display; here’s an example of a more customized histogram:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.hist(data, bins=30, density=True, alpha=0.5,
         histtype=&#39;stepfilled&#39;, color=&#39;steelblue&#39;,
         edgecolor=&#39;none&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_108_0.png" src="_images/matplotlib_108_0.png" />
<p>The <code class="docutils literal notranslate"><span class="pre">plt.hist</span></code> docstring has more information on other customization
options available. I find this combination of <code class="docutils literal notranslate"><span class="pre">histtype='stepfilled'</span></code>
along with some transparency <code class="docutils literal notranslate"><span class="pre">alpha</span></code> to be very useful when comparing
histograms of several distributions:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x1 = np.random.normal(0, 0.8, 1000)
x2 = np.random.normal(-2, 1, 1000)
x3 = np.random.normal(3, 2, 1000)

kwargs = dict(histtype=&#39;stepfilled&#39;, alpha=0.3, density=True, bins=40)

plt.hist(x1, **kwargs)
plt.hist(x2, **kwargs)
plt.hist(x3, **kwargs);
</pre></div>
</div>
<img alt="_images/matplotlib_110_0.png" src="_images/matplotlib_110_0.png" />
<p>If you would like to simply compute the histogram (that is, count the
number of points in a given bin) and not display it, the
<code class="docutils literal notranslate"><span class="pre">np.histogram()</span></code> function is available:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>counts, bin_edges = np.histogram(data, bins=5)
print(counts)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span> <span class="mi">54</span> <span class="mi">262</span> <span class="mi">462</span> <span class="mi">203</span>  <span class="mi">19</span><span class="p">]</span>
</pre></div>
</div>
<p>Just as we create histograms in one dimension by dividing the
number-line into bins, we can also create histograms in two-dimensions
by dividing points among two-dimensional bins. We’ll take a brief look
at several ways to do this here. We’ll start by defining some data—an
<code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> array drawn from a multivariate Gaussian distribution:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>mean = [0, 0]
cov = [[1, 1], [1, 2]]
x, y = np.random.multivariate_normal(mean, cov, 10000).T
</pre></div>
</div>
<div class="section" id="plt-hist2d-two-dimensional-histogram">
<h3><code class="docutils literal notranslate"><span class="pre">plt.hist2d</span></code>: Two-dimensional histogram<a class="headerlink" href="#plt-hist2d-two-dimensional-histogram" title="Permalink to this headline">¶</a></h3>
<p>One straightforward way to plot a two-dimensional histogram is to use
Matplotlib’s <code class="docutils literal notranslate"><span class="pre">plt.hist2d</span></code> function:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.hist2d(x, y, bins=30, cmap=&#39;Blues&#39;)
cb = plt.colorbar()
cb.set_label(&#39;counts in bin&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_116_0.png" src="_images/matplotlib_116_0.png" />
<p>Just as with <code class="docutils literal notranslate"><span class="pre">plt.hist</span></code>, <code class="docutils literal notranslate"><span class="pre">plt.hist2d</span></code> has a number of extra options
to fine-tune the plot and the binning, which are nicely outlined in the
function docstring. Further, just as <code class="docutils literal notranslate"><span class="pre">plt.hist</span></code> has a counterpart in
<code class="docutils literal notranslate"><span class="pre">np.histogram</span></code>, <code class="docutils literal notranslate"><span class="pre">plt.hist2d</span></code> has a counterpart in
<code class="docutils literal notranslate"><span class="pre">np.histogram2d</span></code>, which can be used as follows:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>counts, xedges, yedges = np.histogram2d(x, y, bins=30)
</pre></div>
</div>
</div>
<div class="section" id="plt-hexbin-hexagonal-binnings">
<h3><code class="docutils literal notranslate"><span class="pre">plt.hexbin</span></code>: Hexagonal binnings<a class="headerlink" href="#plt-hexbin-hexagonal-binnings" title="Permalink to this headline">¶</a></h3>
<p>The two-dimensional histogram creates a tesselation of squares across
the axes. Another natural shape for such a tesselation is the regular
hexagon. For this purpose, Matplotlib provides the <code class="docutils literal notranslate"><span class="pre">plt.hexbin</span></code>
routine, which will represents a two-dimensional dataset binned within a
grid of hexagons:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.hexbin(x, y, gridsize=30, cmap=&#39;Blues&#39;)
cb = plt.colorbar(label=&#39;count in bin&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_120_0.png" src="_images/matplotlib_120_0.png" />
<p><code class="docutils literal notranslate"><span class="pre">plt.hexbin</span></code> has a number of interesting options, including the
ability to specify weights for each point, and to change the output in
each bin to any NumPy aggregate (mean of weights, standard deviation of
weights, etc.).</p>
</div>
<div class="section" id="kernel-density-estimation">
<h3>Kernel density estimation<a class="headerlink" href="#kernel-density-estimation" title="Permalink to this headline">¶</a></h3>
<p>Another common method of evaluating densities in multiple dimensions is
<em>kernel density estimation</em> (KDE). This will be discussed more fully in
<a class="reference external" href="05.13-Kernel-Density-Estimation.ipynb">In-Depth: Kernel Density
Estimation</a>, but for now we’ll
simply mention that KDE can be thought of as a way to “smear out” the
points in space and add up the result to obtain a smooth function. One
extremely quick and simple KDE implementation exists in the
<code class="docutils literal notranslate"><span class="pre">scipy.stats</span></code> package. Here is a quick example of using the KDE on
this data:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from scipy.stats import gaussian_kde

# fit an array of size [Ndim, Nsamples]
data = np.vstack([x, y])
kde = gaussian_kde(data)

# evaluate on a regular grid
xgrid = np.linspace(-3.5, 3.5, 40)
ygrid = np.linspace(-6, 6, 40)
Xgrid, Ygrid = np.meshgrid(xgrid, ygrid)
Z = kde.evaluate(np.vstack([Xgrid.ravel(), Ygrid.ravel()]))

# Plot the result as an image
plt.imshow(Z.reshape(Xgrid.shape), origin=&#39;lower&#39;, aspect=&#39;auto&#39;, extent=[-3.5, 3.5, -6, 6], cmap=&#39;Blues&#39;)
cb = plt.colorbar()
cb.set_label(&quot;density&quot;)
</pre></div>
</div>
<img alt="_images/matplotlib_123_0.png" src="_images/matplotlib_123_0.png" />
<p>KDE has a smoothing length that effectively slides the knob between
detail and smoothness (one example of the ubiquitous bias–variance
trade-off). The literature on choosing an appropriate smoothing length
is vast: <code class="docutils literal notranslate"><span class="pre">gaussian_kde</span></code> uses a rule-of-thumb to attempt to find a
nearly optimal smoothing length for the input data.</p>
<p>Other KDE implementations are available within the SciPy ecosystem, each
with its own strengths and weaknesses; see, for example,
<code class="docutils literal notranslate"><span class="pre">sklearn.neighbors.KernelDensity</span></code> and
<code class="docutils literal notranslate"><span class="pre">statsmodels.nonparametric.kernel_density.KDEMultivariate</span></code>.</p>
</div>
</div>
<div class="section" id="customizing-plot-legends">
<h2>Customizing Plot Legends<a class="headerlink" href="#customizing-plot-legends" title="Permalink to this headline">¶</a></h2>
<p>Plot legends give meaning to a visualization, assigning meaning to the
various plot elements. We previously saw how to create a simple legend;
here we’ll take a look at customizing the placement and aesthetics of
the legend in Matplotlib.</p>
<p>The simplest legend can be created with the <code class="docutils literal notranslate"><span class="pre">plt.legend()</span></code> command,
which automatically creates a legend for any labeled plot elements:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import matplotlib.pyplot as plt
plt.style.use(&#39;classic&#39;)
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline
import numpy as np
x = np.linspace(0, 10, 1000)
fig, ax = plt.subplots()
ax.plot(x, np.sin(x), &#39;-b&#39;, label=&#39;Sine&#39;)
ax.plot(x, np.cos(x), &#39;--r&#39;, label=&#39;Cosine&#39;)
ax.axis(&#39;equal&#39;)
leg = ax.legend();
</pre></div>
</div>
<img alt="_images/matplotlib_127_0.png" src="_images/matplotlib_127_0.png" />
<p>But there are many ways we might want to customize such a legend. For
example, we can specify the location and turn off the frame:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax.legend(loc=&#39;upper left&#39;, frameon=False)
fig
</pre></div>
</div>
<img alt="_images/matplotlib_129_0.png" src="_images/matplotlib_129_0.png" />
<p>We can use the <code class="docutils literal notranslate"><span class="pre">ncol</span></code> command to specify the number of columns in the
legend:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax.legend(frameon=False, loc=&#39;lower center&#39;, ncol=2)
fig
</pre></div>
</div>
<img alt="_images/matplotlib_131_0.png" src="_images/matplotlib_131_0.png" />
<p>We can use a rounded box (<code class="docutils literal notranslate"><span class="pre">fancybox</span></code>) or add a shadow, change the
transparency (alpha value) of the frame, or change the padding around
the text:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax.legend(fancybox=True, framealpha=1, shadow=True, borderpad=1)
fig
</pre></div>
</div>
<img alt="_images/matplotlib_133_0.png" src="_images/matplotlib_133_0.png" />
<p>As we have already seen, the legend includes all labeled elements by
default. If this is not what is desired, we can fine-tune which elements
and labels appear in the legend by using the objects returned by plot
commands. The <code class="docutils literal notranslate"><span class="pre">plt.plot()</span></code> command is able to create multiple lines at
once, and returns a list of created line instances. Passing any of these
to <code class="docutils literal notranslate"><span class="pre">plt.legend()</span></code> will tell it which to identify, along with the
labels we’d like to specify:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>y = np.sin(x[:, np.newaxis] + np.pi * np.arange(0, 2, 0.5))
lines = plt.plot(x, y)

# lines is a list of plt.Line2D instances
plt.legend(lines[:2], [&#39;first&#39;, &#39;second&#39;]);
</pre></div>
</div>
<img alt="_images/matplotlib_135_0.png" src="_images/matplotlib_135_0.png" />
<p>I generally find in practice that it is clearer to use the first method,
applying labels to the plot elements you’d like to show on the legend:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.plot(x, y[:, 0], label=&#39;first&#39;)
plt.plot(x, y[:, 1], label=&#39;second&#39;)
plt.plot(x, y[:, 2:])
plt.legend(framealpha=1, frameon=True);
</pre></div>
</div>
<img alt="_images/matplotlib_137_0.png" src="_images/matplotlib_137_0.png" />
<p>Sometimes the legend defaults are not sufficient for the given
visualization. For example, perhaps you’re be using the size of points
to mark certain features of the data, and want to create a legend
reflecting this. Here is an example where we’ll use the size of points
to indicate populations of California cities. We’d like a legend that
specifies the scale of the sizes of the points, and we’ll accomplish
this by plotting some labeled data with no entries:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import pandas as pd
cities = pd.read_csv(&#39;data/california_cities.csv&#39;)

# Extract the data we&#39;re interested in
lat, lon = cities[&#39;latd&#39;], cities[&#39;longd&#39;]
population, area = cities[&#39;population_total&#39;], cities[&#39;area_total_km2&#39;]

# Scatter the points, using size and color but no label
plt.scatter(lon, lat, label=None, c=np.log10(population), cmap=&#39;viridis&#39;, s=area, linewidth=0, alpha=0.5)
plt.axis(aspect=&#39;equal&#39;)
plt.xlabel(&#39;longitude&#39;)
plt.ylabel(&#39;latitude&#39;)
plt.colorbar(label=&#39;log$_{10}$(population)&#39;)
plt.clim(3, 7)

# Here we create a legend:
# we&#39;ll plot empty lists with the desired size and label
for area in [100, 300, 500]:
    plt.scatter([], [], c=&#39;k&#39;, alpha=0.3, s=area, label=str(area) + &#39; km$^2$&#39;)
plt.legend(scatterpoints=1, frameon=False, labelspacing=1, title=&#39;City Area&#39;)

plt.title(&#39;California Cities: Area and Population&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_139_0.png" src="_images/matplotlib_139_0.png" />
<p>The legend will always reference some object that is on the plot, so if
we’d like to display a particular shape we need to plot it. In this
case, the objects we want (gray circles) are not on the plot, so we fake
them by plotting empty lists. Notice too that the legend only lists plot
elements that have a label specified.</p>
<p>By plotting empty lists, we create labeled plot objects which are picked
up by the legend, and now our legend tells us some useful information.
This strategy can be useful for creating more sophisticated
visualizations.</p>
<p>Finally, note that for geographic data like this, it would be clearer if
we could show state boundaries or other map-specific elements.</p>
<p>Sometimes when designing a plot you’d like to add multiple legends to
the same axes. Unfortunately, Matplotlib does not make this easy: via
the standard <code class="docutils literal notranslate"><span class="pre">legend</span></code> interface, it is only possible to create a
single legend for the entire plot. If you try to create a second legend
using <code class="docutils literal notranslate"><span class="pre">plt.legend()</span></code> or <code class="docutils literal notranslate"><span class="pre">ax.legend()</span></code>, it will simply override the
first one. We can work around this by creating a new legend artist from
scratch, and then using the lower-level <code class="docutils literal notranslate"><span class="pre">ax.add_artist()</span></code> method to
manually add the second artist to the plot:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig, ax = plt.subplots()

lines = []
styles = [&#39;-&#39;, &#39;--&#39;, &#39;-.&#39;, &#39;:&#39;]
x = np.linspace(0, 10, 1000)

for i in range(4):
    lines += ax.plot(x, np.sin(x - i * np.pi / 2), styles[i], color=&#39;black&#39;)
ax.axis(&#39;equal&#39;)

# specify the lines and labels of the first legend
ax.legend(lines[:2], [&#39;line A&#39;, &#39;line B&#39;], loc=&#39;upper right&#39;, frameon=False)

# Create the second legend and add the artist manually.
from matplotlib.legend import Legend
leg = Legend(ax, lines[2:], [&#39;line C&#39;, &#39;line D&#39;], loc=&#39;lower right&#39;, frameon=False)
ax.add_artist(leg);
</pre></div>
</div>
<img alt="_images/matplotlib_142_0.png" src="_images/matplotlib_142_0.png" />
</div>
<div class="section" id="customizing-colorbars">
<h2>Customizing Colorbars<a class="headerlink" href="#customizing-colorbars" title="Permalink to this headline">¶</a></h2>
<p>Plot legends identify discrete labels of discrete points. For continuous
labels based on the color of points, lines, or regions, a labeled
colorbar can be a great tool. In Matplotlib, a colorbar is a separate
axes that can provide a key for the meaning of colors in a plot. Because
the book is printed in black-and-white, this section has an accompanying
online supplement where you can view the figures in full color
(<a class="reference external" href="https://github.com/jakevdp/PythonDataScienceHandbook">https://github.com/jakevdp/PythonDataScienceHandbook</a>). We’ll start by
setting up the notebook for plotting and importing the functions we will
use:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import matplotlib.pyplot as plt
plt.style.use(&#39;classic&#39;)
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline
import numpy as np
</pre></div>
</div>
<p>As we have seen several times throughout this section, the simplest
colorbar can be created with the <code class="docutils literal notranslate"><span class="pre">plt.colorbar</span></code> function:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x = np.linspace(0, 10, 1000)
I = np.sin(x) * np.cos(x[:, np.newaxis])

plt.imshow(I)
plt.colorbar();
</pre></div>
</div>
<img alt="_images/matplotlib_147_0.png" src="_images/matplotlib_147_0.png" />
<p>The colormap can be specified using the <code class="docutils literal notranslate"><span class="pre">cmap</span></code> argument to the
plotting function that is creating the visualization:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.imshow(I, cmap=&#39;gray&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_149_0.png" src="_images/matplotlib_149_0.png" />
<div class="section" id="choosing-the-colormap">
<h3>Choosing the Colormap<a class="headerlink" href="#choosing-the-colormap" title="Permalink to this headline">¶</a></h3>
<p>A full treatment of color choice within visualization is beyond the
scope of this book, but for entertaining reading on this subject and
others, see the article <a class="reference external" href="http://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1003833">“Ten Simple Rules for Better
Figures”</a>.
Matplotlib’s online documentation also has an <a class="reference external" href="http://Matplotlib.org/1.4.1/users/colormaps.html">interesting
discussion</a> of
colormap choice.</p>
<p>Broadly, you should be aware of three different categories of colormaps:</p>
<ul class="simple">
<li><p><em>Sequential colormaps</em>: These are made up of one continuous sequence
of colors (e.g., <code class="docutils literal notranslate"><span class="pre">binary</span></code> or <code class="docutils literal notranslate"><span class="pre">viridis</span></code>).</p></li>
<li><p><em>Divergent colormaps</em>: These usually contain two distinct colors,
which show positive and negative deviations from a mean (e.g.,
<code class="docutils literal notranslate"><span class="pre">RdBu</span></code> or <code class="docutils literal notranslate"><span class="pre">PuOr</span></code>).</p></li>
<li><p><em>Qualitative colormaps</em>: these mix colors with no particular sequence
(e.g., <code class="docutils literal notranslate"><span class="pre">rainbow</span></code> or <code class="docutils literal notranslate"><span class="pre">jet</span></code>).</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">jet</span></code> colormap, which was the default in Matplotlib prior to
version 2.0, is an example of a qualitative colormap. Its status as the
default was quite unfortunate, because qualitative maps are often a poor
choice for representing quantitative data. Among the problems is the
fact that qualitative maps usually do not display any uniform
progression in brightness as the scale increases.</p>
<p>We can see this by converting the <code class="docutils literal notranslate"><span class="pre">jet</span></code> colorbar into black and white:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from matplotlib.colors import LinearSegmentedColormap

def grayscale_cmap(cmap):
    &quot;&quot;&quot;Return a grayscale version of the given colormap&quot;&quot;&quot;
    cmap = plt.cm.get_cmap(cmap)
    colors = cmap(np.arange(cmap.N))

    # convert RGBA to perceived grayscale luminance
    # cf. http://alienryderflex.com/hsp.html
    RGB_weight = [0.299, 0.587, 0.114]
    luminance = np.sqrt(np.dot(colors[:, :3] ** 2, RGB_weight))
    colors[:, :3] = luminance[:, np.newaxis]

    return LinearSegmentedColormap.from_list(cmap.name + &quot;_gray&quot;, colors, cmap.N)


def view_colormap(cmap):
    &quot;&quot;&quot;Plot a colormap with its grayscale equivalent&quot;&quot;&quot;
    cmap = plt.cm.get_cmap(cmap)
    colors = cmap(np.arange(cmap.N))

    cmap = grayscale_cmap(cmap)
    grayscale = cmap(np.arange(cmap.N))

    fig, ax = plt.subplots(2, figsize=(6, 2), subplot_kw=dict(xticks=[], yticks=[]))
    ax[0].imshow([colors], extent=[0, 10, 0, 1])
    ax[1].imshow([grayscale], extent=[0, 10, 0, 1])
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>view_colormap(&#39;jet&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_153_0.png" src="_images/matplotlib_153_0.png" />
<p>Notice the bright stripes in the grayscale image. Even in full color,
this uneven brightness means that the eye will be drawn to certain
portions of the color range, which will potentially emphasize
unimportant parts of the dataset. It’s better to use a colormap such as
<code class="docutils literal notranslate"><span class="pre">viridis</span></code> (the default as of Matplotlib 2.0), which is specifically
constructed to have an even brightness variation across the range.</p>
<p>Thus it not only plays well with our color perception, but also will
translate well to grayscale printing:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>view_colormap(&#39;viridis&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_156_0.png" src="_images/matplotlib_156_0.png" />
<p>If you favor rainbow schemes, another good option for continuous data is
the <code class="docutils literal notranslate"><span class="pre">cubehelix</span></code> colormap:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>view_colormap(&#39;cubehelix&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_158_0.png" src="_images/matplotlib_158_0.png" />
<p>For other situations, such as showing positive and negative deviations
from some mean, dual-color colorbars such as <code class="docutils literal notranslate"><span class="pre">RdBu</span></code> (<em>Red-Blue</em>) can
be useful. However, as you can see in the following figure, it’s
important to note that the positive-negative information will be lost
upon translation to grayscale!</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>view_colormap(&#39;RdBu&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_160_0.png" src="_images/matplotlib_160_0.png" />
</div>
<div class="section" id="color-limits-and-extensions">
<h3>Color limits and extensions<a class="headerlink" href="#color-limits-and-extensions" title="Permalink to this headline">¶</a></h3>
<p>Matplotlib allows for a large range of colorbar customization. The
colorbar itself is simply an instance of <code class="docutils literal notranslate"><span class="pre">plt.Axes</span></code>, so all of the
axes and tick formatting tricks we’ve learned are applicable. The
colorbar has some interesting flexibility: for example, we can narrow
the color limits and indicate the out-of-bounds values with a triangular
arrow at the top and bottom by setting the <code class="docutils literal notranslate"><span class="pre">extend</span></code> property. This
might come in handy, for example, if displaying an image that is subject
to noise:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># make noise in 1% of the image pixels
speckles = (np.random.random(I.shape) &lt; 0.01)
I[speckles] = np.random.normal(0, 3, np.count_nonzero(speckles))

plt.figure(figsize=(10, 3.5))

plt.subplot(1, 2, 1)
plt.imshow(I, cmap=&#39;RdBu&#39;)
plt.colorbar()

plt.subplot(1, 2, 2)
plt.imshow(I, cmap=&#39;RdBu&#39;)
plt.colorbar(extend=&#39;both&#39;)
plt.clim(-1, 1);
</pre></div>
</div>
<img alt="_images/matplotlib_162_0.png" src="_images/matplotlib_162_0.png" />
<p>Notice that in the left panel, the default color limits respond to the
noisy pixels, and the range of the noise completely washes-out the
pattern we are interested in. In the right panel, we manually set the
color limits, and add extensions to indicate values which are above or
below those limits. The result is a much more useful visualization of
our data.</p>
</div>
<div class="section" id="discrete-color-bars">
<h3>Discrete Color Bars<a class="headerlink" href="#discrete-color-bars" title="Permalink to this headline">¶</a></h3>
<p>Colormaps are by default continuous, but sometimes you’d like to
represent discrete values. The easiest way to do this is to use the
<code class="docutils literal notranslate"><span class="pre">plt.cm.get_cmap()</span></code> function, and pass the name of a suitable colormap
along with the number of desired bins:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.imshow(I, cmap=plt.cm.get_cmap(&#39;Blues&#39;, 6))
plt.colorbar()
plt.clim(-1, 1);
</pre></div>
</div>
<img alt="_images/matplotlib_165_0.png" src="_images/matplotlib_165_0.png" />
<div class="section" id="example-handwritten-digits">
<h4>Example: Handwritten Digits<a class="headerlink" href="#example-handwritten-digits" title="Permalink to this headline">¶</a></h4>
<p>For an example of where this might be useful, let’s look at an
interesting visualization of some hand written digits data. This data is
included in Scikit-Learn, and consists of nearly 2,000
<span class="math notranslate nohighlight">\(8 \times 8\)</span> thumbnails showing various hand-written digits.</p>
<p>For now, let’s start by downloading the digits data and visualizing
several of the example images with <code class="docutils literal notranslate"><span class="pre">plt.imshow()</span></code>:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># load images of the digits 0 through 5 and visualize several of them
from sklearn.datasets import load_digits
digits = load_digits(n_class=6)

fig, ax = plt.subplots(8, 8, figsize=(6, 6))
for i, axi in enumerate(ax.flat):
    axi.imshow(digits.images[i], cmap=&#39;binary&#39;)
    axi.set(xticks=[], yticks=[])
</pre></div>
</div>
<img alt="_images/matplotlib_168_0.png" src="_images/matplotlib_168_0.png" />
<p>Because each digit is defined by the hue of its 64 pixels, we can
consider each digit to be a point lying in 64-dimensional space: each
dimension represents the brightness of one pixel. But visualizing
relationships in such high-dimensional spaces can be extremely
difficult. One way to approach this is to use a <em>dimensionality
reduction</em> technique such as manifold learning to reduce the
dimensionality of the data while maintaining the relationships of
interest.</p>
<p>Deferring the discussion of these details, let’s take a look at a
two-dimensional manifold learning projection of this digits data:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># project the digits into 2 dimensions using IsoMap
from sklearn.manifold import Isomap
iso = Isomap(n_components=2)
projection = iso.fit_transform(digits.data)
</pre></div>
</div>
<p>We’ll use our discrete colormap to view the results, setting the
<code class="docutils literal notranslate"><span class="pre">ticks</span></code> and <code class="docutils literal notranslate"><span class="pre">clim</span></code> to improve the aesthetics of the resulting
colorbar:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># plot the results
plt.scatter(projection[:, 0], projection[:, 1], lw=0.1,
            c=digits.target, cmap=plt.cm.get_cmap(&#39;cubehelix&#39;, 6))
plt.colorbar(ticks=range(6), label=&#39;digit value&#39;)
plt.clim(-0.5, 5.5)
</pre></div>
</div>
<img alt="_images/matplotlib_173_0.png" src="_images/matplotlib_173_0.png" />
<p>The projection also gives us some interesting insights on the
relationships within the dataset: for example, the ranges of 5 and 3
nearly overlap in this projection, indicating that some hand written
fives and threes are difficult to distinguish, and therefore more likely
to be confused by an automated classification algorithm. Other values,
like 0 and 1, are more distantly separated, and therefore much less
likely to be confused. This observation agrees with our intuition,
because 5 and 3 look much more similar than do 0 and 1.</p>
</div>
</div>
</div>
<div class="section" id="multiple-subplots">
<h2>Multiple Subplots<a class="headerlink" href="#multiple-subplots" title="Permalink to this headline">¶</a></h2>
<p>Sometimes it is helpful to compare different views of data side by side.
To this end, Matplotlib has the concept of <em>subplots</em>: groups of smaller
axes that can exist together within a single figure. These subplots
might be insets, grids of plots, or other more complicated layouts. In
this section we’ll explore four routines for creating subplots in
Matplotlib.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline
import matplotlib.pyplot as plt
plt.style.use(&#39;seaborn-white&#39;)
import numpy as np
</pre></div>
</div>
<p>The most basic method of creating an axes is to use the <code class="docutils literal notranslate"><span class="pre">plt.axes</span></code>
function. As we’ve seen previously, by default this creates a standard
axes object that fills the entire figure. <code class="docutils literal notranslate"><span class="pre">plt.axes</span></code> also takes an
optional argument that is a list of four numbers in the figure
coordinate system. These numbers represent
<code class="docutils literal notranslate"><span class="pre">[left,</span> <span class="pre">bottom,</span> <span class="pre">width,</span> <span class="pre">height]</span></code> in the figure coordinate system, which
ranges from 0 at the bottom left of the figure to 1 at the top right of
the figure.</p>
<p>For example, we might create an inset axes at the top-right corner of
another axes by setting the <em>x</em> and <em>y</em> position to 0.65 (that is,
starting at 65% of the width and 65% of the height of the figure) and
the <em>x</em> and <em>y</em> extents to 0.2 (that is, the size of the axes is 20% of
the width and 20% of the height of the figure):</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax1 = plt.axes()  # standard axes
ax2 = plt.axes([0.65, 0.65, 0.2, 0.2])
</pre></div>
</div>
<img alt="_images/matplotlib_179_0.png" src="_images/matplotlib_179_0.png" />
<p>The equivalent of this command within the object-oriented interface is
<code class="docutils literal notranslate"><span class="pre">fig.add_axes()</span></code>. Let’s use this to create two vertically stacked
axes:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = plt.figure()
ax1 = fig.add_axes([0.1, 0.5, 0.8, 0.4],
                   xticklabels=[], ylim=(-1.2, 1.2))
ax2 = fig.add_axes([0.1, 0.1, 0.8, 0.4],
                   ylim=(-1.2, 1.2))

x = np.linspace(0, 10)
ax1.plot(np.sin(x))
ax2.plot(np.cos(x));
</pre></div>
</div>
<img alt="_images/matplotlib_181_0.png" src="_images/matplotlib_181_0.png" />
<p>Aligned columns or rows of subplots are a common-enough need that
Matplotlib has several convenience routines that make them easy to
create. The lowest level of these is <code class="docutils literal notranslate"><span class="pre">plt.subplot()</span></code>, which creates a
single subplot within a grid. As you can see, this command takes three
integer arguments—the number of rows, the number of columns, and the
index of the plot to be created in this scheme, which runs from the
upper left to the bottom right:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for i in range(1, 7):
    plt.subplot(2, 3, i)
    plt.text(0.5, 0.5, str((2, 3, i)),
             fontsize=18, ha=&#39;center&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_183_0.png" src="_images/matplotlib_183_0.png" />
<p>The command <code class="docutils literal notranslate"><span class="pre">plt.subplots_adjust</span></code> can be used to adjust the spacing
between these plots. The following code uses the equivalent
object-oriented command, <code class="docutils literal notranslate"><span class="pre">fig.add_subplot()</span></code>:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = plt.figure()
fig.subplots_adjust(hspace=0.4, wspace=0.4)
for i in range(1, 7):
    ax = fig.add_subplot(2, 3, i)
    ax.text(0.5, 0.5, str((2, 3, i)),
           fontsize=18, ha=&#39;center&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_185_0.png" src="_images/matplotlib_185_0.png" />
<p>We’ve used the <code class="docutils literal notranslate"><span class="pre">hspace</span></code> and <code class="docutils literal notranslate"><span class="pre">wspace</span></code> arguments of
<code class="docutils literal notranslate"><span class="pre">plt.subplots_adjust</span></code>, which specify the spacing along the height and
width of the figure, in units of the subplot size (in this case, the
space is 40% of the subplot width and height).</p>
<p>The approach just described can become quite tedious when creating a
large grid of subplots, especially if you’d like to hide the x- and
y-axis labels on the inner plots. For this purpose, <code class="docutils literal notranslate"><span class="pre">plt.subplots()</span></code>
is the easier tool to use (note the <code class="docutils literal notranslate"><span class="pre">s</span></code> at the end of <code class="docutils literal notranslate"><span class="pre">subplots</span></code>).
Rather than creating a single subplot, this function creates a full grid
of subplots in a single line, returning them in a NumPy array. The
arguments are the number of rows and number of columns, along with
optional keywords <code class="docutils literal notranslate"><span class="pre">sharex</span></code> and <code class="docutils literal notranslate"><span class="pre">sharey</span></code>, which allow you to specify
the relationships between different axes.</p>
<p>Here we’ll create a <span class="math notranslate nohighlight">\(2 \times 3\)</span> grid of subplots, where all axes
in the same row share their y-axis scale, and all axes in the same
column share their x-axis scale:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig, ax = plt.subplots(2, 3, sharex=&#39;col&#39;, sharey=&#39;row&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_189_0.png" src="_images/matplotlib_189_0.png" />
<p>Note that by specifying <code class="docutils literal notranslate"><span class="pre">sharex</span></code> and <code class="docutils literal notranslate"><span class="pre">sharey</span></code>, we’ve automatically
removed inner labels on the grid to make the plot cleaner. The resulting
grid of axes instances is returned within a NumPy array, allowing for
convenient specification of the desired axes using standard array
indexing notation:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># axes are in a two-dimensional array, indexed by [row, col]
for i in range(2):
    for j in range(3):
        ax[i, j].text(0.5, 0.5, str((i, j)),
                      fontsize=18, ha=&#39;center&#39;)
fig
</pre></div>
</div>
<img alt="_images/matplotlib_191_0.png" src="_images/matplotlib_191_0.png" />
<p>To go beyond a regular grid to subplots that span multiple rows and
columns, <code class="docutils literal notranslate"><span class="pre">plt.GridSpec()</span></code> is the best tool. The <code class="docutils literal notranslate"><span class="pre">plt.GridSpec()</span></code>
object does not create a plot by itself; it is simply a convenient
interface that is recognized by the <code class="docutils literal notranslate"><span class="pre">plt.subplot()</span></code> command. For
example, a gridspec for a grid of two rows and three columns with some
specified width and height space looks like this:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>grid = plt.GridSpec(2, 3, wspace=0.4, hspace=0.3)
</pre></div>
</div>
<p>From this we can specify subplot locations and extents using the
familiary Python slicing syntax:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.subplot(grid[0, 0])
plt.subplot(grid[0, 1:])
plt.subplot(grid[1, :2])
plt.subplot(grid[1, 2]);
</pre></div>
</div>
<img alt="_images/matplotlib_195_0.png" src="_images/matplotlib_195_0.png" />
<p>This type of flexible grid alignment has a wide range of uses. I most
often use it when creating multi-axes histogram plots like the ones
shown here:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Create some normally distributed data
mean = [0, 0]
cov = [[1, 1], [1, 2]]
x, y = np.random.multivariate_normal(mean, cov, 3000).T
# Set up the axes with gridspec
fig = plt.figure(figsize=(6, 6))
grid = plt.GridSpec(4, 4, hspace=0.2, wspace=0.2)
main_ax = fig.add_subplot(grid[:-1, 1:])
y_hist = fig.add_subplot(grid[:-1, 0], xticklabels=[], sharey=main_ax)
x_hist = fig.add_subplot(grid[-1, 1:], yticklabels=[], sharex=main_ax)
# scatter points on the main axes
main_ax.plot(x, y, &#39;ok&#39;, markersize=3, alpha=0.2)
# histogram on the attached axes
x_hist.hist(x, 40, histtype=&#39;stepfilled&#39;, orientation=&#39;vertical&#39;, color=&#39;gray&#39;)
x_hist.invert_yaxis()
y_hist.hist(y, 40, histtype=&#39;stepfilled&#39;, orientation=&#39;horizontal&#39;, color=&#39;gray&#39;)
y_hist.invert_xaxis()
</pre></div>
</div>
<img alt="_images/matplotlib_197_0.png" src="_images/matplotlib_197_0.png" />
</div>
<div class="section" id="text-and-annotation">
<h2>Text and Annotation<a class="headerlink" href="#text-and-annotation" title="Permalink to this headline">¶</a></h2>
<p>Creating a good visualization involves guiding the reader so that the
figure tells a story. In some cases, this story can be told in an
entirely visual manner, without the need for added text, but in others,
small textual cues and labels are necessary. Perhaps the most basic
types of annotations you will use are axes labels and titles, but the
options go beyond this. Let’s take a look at some data and how we might
visualize and annotate it to help convey interesting information. We’ll
start by setting up the notebook for plotting and importing the
functions we will use:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline
import matplotlib.pyplot as plt
import matplotlib as mpl
plt.style.use(&#39;seaborn-whitegrid&#39;)
import numpy as np
import pandas as pd
</pre></div>
</div>
<p>Let’s return to some data we worked with earler, in <a class="reference external" href="03.09-Pivot-Tables.ipynb#Example:-Birthrate-Data">“Example: Birthrate
Data”</a>, where we
generated a plot of average births over the course of the calendar year;
as already mentioned, that this data can be downloaded at
<a class="reference external" href="https://raw.githubusercontent.com/jakevdp/data-CDCbirths/master/births.csv">https://raw.githubusercontent.com/jakevdp/data-CDCbirths/master/births.csv</a>.</p>
<p>We’ll start with the same cleaning procedure we used there, and plot the
results:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from datetime import datetime
births = pd.read_csv(&#39;data/births.csv&#39;)

quartiles = np.percentile(births[&#39;births&#39;], [25, 50, 75])
mu, sig = quartiles[1], 0.74 * (quartiles[2] - quartiles[0])
births = births.query(&#39;(births &gt; @mu - 5 * @sig) &amp; (births &lt; @mu + 5 * @sig)&#39;)
births[&#39;day&#39;] = births[&#39;day&#39;].astype(int)
births.index = pd.to_datetime(10000 * births.year + 100 * births.month + births.day, format=&#39;%Y%m%d&#39;)
births_by_date = births.pivot_table(&#39;births&#39;, [births.index.month, births.index.day])
births_by_date.index = [datetime(2012, month, day) for (month, day) in births_by_date.index]
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig, ax = plt.subplots(figsize=(12, 4))
births_by_date.plot(ax=ax);
</pre></div>
</div>
<img alt="_images/matplotlib_202_0.png" src="_images/matplotlib_202_0.png" />
<p>When we’re communicating data like this, it is often useful to annotate
certain features of the plot to draw the reader’s attention. This can be
done manually with the <code class="docutils literal notranslate"><span class="pre">plt.text</span></code>/<code class="docutils literal notranslate"><span class="pre">ax.text</span></code> command, which will
place text at a particular x/y value:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig, ax = plt.subplots(figsize=(12, 4))
births_by_date.plot(ax=ax)

# Add labels to the plot
style = dict(size=10, color=&#39;gray&#39;)

ax.text(&#39;2012-1-1&#39;, 3950, &quot;New Year&#39;s Day&quot;, **style)
ax.text(&#39;2012-7-4&#39;, 4250, &quot;Independence Day&quot;, ha=&#39;center&#39;, **style)
ax.text(&#39;2012-9-4&#39;, 4850, &quot;Labor Day&quot;, ha=&#39;center&#39;, **style)
ax.text(&#39;2012-10-31&#39;, 4600, &quot;Halloween&quot;, ha=&#39;right&#39;, **style)
ax.text(&#39;2012-11-25&#39;, 4450, &quot;Thanksgiving&quot;, ha=&#39;center&#39;, **style)
ax.text(&#39;2012-12-25&#39;, 3850, &quot;Christmas &quot;, ha=&#39;right&#39;, **style)

# Label the axes
ax.set(title=&#39;USA births by day of year (1969-1988)&#39;, ylabel=&#39;average daily births&#39;)

# Format the x axis with centered month labels
ax.xaxis.set_major_locator(mpl.dates.MonthLocator())
ax.xaxis.set_minor_locator(mpl.dates.MonthLocator(bymonthday=15))
ax.xaxis.set_major_formatter(plt.NullFormatter())
ax.xaxis.set_minor_formatter(mpl.dates.DateFormatter(&#39;%h&#39;));
</pre></div>
</div>
<img alt="_images/matplotlib_204_0.png" src="_images/matplotlib_204_0.png" />
<p>The <code class="docutils literal notranslate"><span class="pre">ax.text</span></code> method takes an x position, a y position, a string, and
then optional keywords specifying the color, size, style, alignment, and
other properties of the text. Here we used <code class="docutils literal notranslate"><span class="pre">ha='right'</span></code> and
<code class="docutils literal notranslate"><span class="pre">ha='center'</span></code>, where <code class="docutils literal notranslate"><span class="pre">ha</span></code> is short for <em>horizonal alignment</em>. See
the docstring of <code class="docutils literal notranslate"><span class="pre">plt.text()</span></code> and of <code class="docutils literal notranslate"><span class="pre">mpl.text.Text()</span></code> for more
information on available options.</p>
<p>In the previous example, we have anchored our text annotations to data
locations. Sometimes it’s preferable to anchor the text to a position on
the axes or figure, independent of the data. In Matplotlib, this is done
by modifying the <em>transform</em>.</p>
<p>Any graphics display framework needs some scheme for translating between
coordinate systems. For example, a data point at <span class="math notranslate nohighlight">\((x, y) = (1, 1)\)</span>
needs to somehow be represented at a certain location on the figure,
which in turn needs to be represented in pixels on the screen.
Mathematically, such coordinate transformations are relatively
straightforward, and Matplotlib has a well-developed set of tools that
it uses internally to perform them (these tools can be explored in the
<code class="docutils literal notranslate"><span class="pre">matplotlib.transforms</span></code> submodule).</p>
<p>The average user rarely needs to worry about the details of these
transforms, but it is helpful knowledge to have when considering the
placement of text on a figure. There are three pre-defined transforms
that can be useful in this situation:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ax.transData</span></code>: Transform associated with data coordinates</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ax.transAxes</span></code>: Transform associated with the axes (in units of
axes dimensions)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fig.transFigure</span></code>: Transform associated with the figure (in units
of figure dimensions)</p></li>
</ul>
<p>Here let’s look at an example of drawing text at various locations using
these transforms:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig, ax = plt.subplots(facecolor=&#39;lightgray&#39;)
ax.axis([0, 10, 0, 10])

# transform=ax.transData is the default, but we&#39;ll specify it anyway
ax.text(1, 5, &quot;. Data: (1, 5)&quot;, transform=ax.transData)
ax.text(0.5, 0.1, &quot;. Axes: (0.5, 0.1)&quot;, transform=ax.transAxes)
ax.text(0.2, 0.2, &quot;. Figure: (0.2, 0.2)&quot;, transform=fig.transFigure);
</pre></div>
</div>
<img alt="_images/matplotlib_208_0.png" src="_images/matplotlib_208_0.png" />
<p>Note that by default, the text is aligned above and to the left of the
specified coordinates: here the “.” at the beginning of each string will
approximately mark the given coordinate location.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">transData</span></code> coordinates give the usual data coordinates associated
with the x- and y-axis labels. The <code class="docutils literal notranslate"><span class="pre">transAxes</span></code> coordinates give the
location from the bottom-left corner of the axes (here the white box),
as a fraction of the axes size. The <code class="docutils literal notranslate"><span class="pre">transFigure</span></code> coordinates are
similar, but specify the position from the bottom-left of the figure
(here the gray box), as a fraction of the figure size.</p>
<p>Notice now that if we change the axes limits, it is only the
<code class="docutils literal notranslate"><span class="pre">transData</span></code> coordinates that will be affected, while the others remain
stationary:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax.set_xlim(0, 2)
ax.set_ylim(-6, 6)
fig
</pre></div>
</div>
<img alt="_images/matplotlib_211_0.png" src="_images/matplotlib_211_0.png" />
<p>This behavior can be seen more clearly by changing the axes limits
interactively: if you are executing this code in a notebook, you can
make that happen by changing <code class="docutils literal notranslate"><span class="pre">%matplotlib</span> <span class="pre">inline</span></code> to
<code class="docutils literal notranslate"><span class="pre">%matplotlib</span> <span class="pre">notebook</span></code> and using each plot’s menu to interact with the
plot.</p>
<p>Along with tick marks and text, another useful annotation mark is the
simple arrow.</p>
<p>Drawing arrows in Matplotlib is often much harder than you’d bargain
for. While there is a <code class="docutils literal notranslate"><span class="pre">plt.arrow()</span></code> function available, I wouldn’t
suggest using it: the arrows it creates are SVG objects that will be
subject to the varying aspect ratio of your plots, and the result is
rarely what the user intended. Instead, I’d suggest using the
<code class="docutils literal notranslate"><span class="pre">plt.annotate()</span></code> function. This function creates some text and an
arrow, and the arrows can be very flexibly specified.</p>
<p>Here we’ll use <code class="docutils literal notranslate"><span class="pre">annotate</span></code> with several of its options:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline

fig, ax = plt.subplots()

x = np.linspace(0, 20, 1000)
ax.plot(x, np.cos(x))
ax.axis(&#39;equal&#39;)

ax.annotate(&#39;local maximum&#39;, xy=(6.28, 1), xytext=(10, 4),
            arrowprops=dict(facecolor=&#39;black&#39;, shrink=0.05))

ax.annotate(&#39;local minimum&#39;, xy=(5 * np.pi, -1), xytext=(2, -6),
            arrowprops=dict(arrowstyle=&quot;-&gt;&quot;,
                            connectionstyle=&quot;angle3,angleA=0,angleB=-90&quot;));
</pre></div>
</div>
<img alt="_images/matplotlib_215_0.png" src="_images/matplotlib_215_0.png" />
<p>The arrow style is controlled through the <code class="docutils literal notranslate"><span class="pre">arrowprops</span></code> dictionary,
which has numerous options available. These options are fairly
well-documented in Matplotlib’s online documentation, so rather than
repeating them here it is probably more useful to quickly show some of
the possibilities. Let’s demonstrate several of the possible options
using the birthrate plot from before:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig, ax = plt.subplots(figsize=(12, 4))
births_by_date.plot(ax=ax)

# Add labels to the plot
ax.annotate(&quot;New Year&#39;s Day&quot;, xy=(&#39;2012-1-1&#39;, 4100),  xycoords=&#39;data&#39;,
            xytext=(50, -30), textcoords=&#39;offset points&#39;,
            arrowprops=dict(arrowstyle=&quot;-&gt;&quot;,
                            connectionstyle=&quot;arc3,rad=-0.2&quot;))

ax.annotate(&quot;Independence Day&quot;, xy=(&#39;2012-7-4&#39;, 4250),  xycoords=&#39;data&#39;,
            bbox=dict(boxstyle=&quot;round&quot;, fc=&quot;none&quot;, ec=&quot;gray&quot;),
            xytext=(10, -40), textcoords=&#39;offset points&#39;, ha=&#39;center&#39;,
            arrowprops=dict(arrowstyle=&quot;-&gt;&quot;))

ax.annotate(&#39;Labor Day&#39;, xy=(&#39;2012-9-4&#39;, 4850), xycoords=&#39;data&#39;, ha=&#39;center&#39;,
            xytext=(0, -20), textcoords=&#39;offset points&#39;)
ax.annotate(&#39;&#39;, xy=(&#39;2012-9-1&#39;, 4850), xytext=(&#39;2012-9-7&#39;, 4850),
            xycoords=&#39;data&#39;, textcoords=&#39;data&#39;,
            arrowprops={&#39;arrowstyle&#39;: &#39;|-|,widthA=0.2,widthB=0.2&#39;, })

ax.annotate(&#39;Halloween&#39;, xy=(&#39;2012-10-31&#39;, 4600),  xycoords=&#39;data&#39;,
            xytext=(-80, -40), textcoords=&#39;offset points&#39;,
            arrowprops=dict(arrowstyle=&quot;fancy&quot;,
                            fc=&quot;0.6&quot;, ec=&quot;none&quot;,
                            connectionstyle=&quot;angle3,angleA=0,angleB=-90&quot;))

ax.annotate(&#39;Thanksgiving&#39;, xy=(&#39;2012-11-25&#39;, 4500),  xycoords=&#39;data&#39;,
            xytext=(-120, -60), textcoords=&#39;offset points&#39;,
            bbox=dict(boxstyle=&quot;round4,pad=.5&quot;, fc=&quot;0.9&quot;),
            arrowprops=dict(arrowstyle=&quot;-&gt;&quot;,
                            connectionstyle=&quot;angle,angleA=0,angleB=80,rad=20&quot;))


ax.annotate(&#39;Christmas&#39;, xy=(&#39;2012-12-25&#39;, 3850),  xycoords=&#39;data&#39;,
             xytext=(-30, 0), textcoords=&#39;offset points&#39;,
             size=13, ha=&#39;right&#39;, va=&quot;center&quot;,
             bbox=dict(boxstyle=&quot;round&quot;, alpha=0.1),
             arrowprops=dict(arrowstyle=&quot;wedge,tail_width=0.5&quot;, alpha=0.1));

# Label the axes
ax.set(title=&#39;USA births by day of year (1969-1988)&#39;,
       ylabel=&#39;average daily births&#39;)

# Format the x axis with centered month labels
ax.xaxis.set_major_locator(mpl.dates.MonthLocator())
ax.xaxis.set_minor_locator(mpl.dates.MonthLocator(bymonthday=15))
ax.xaxis.set_major_formatter(plt.NullFormatter())
ax.xaxis.set_minor_formatter(mpl.dates.DateFormatter(&#39;%h&#39;));

ax.set_ylim(3600, 5400);
</pre></div>
</div>
<img alt="_images/matplotlib_217_0.png" src="_images/matplotlib_217_0.png" />
</div>
<div class="section" id="customizing-ticks">
<h2>Customizing Ticks<a class="headerlink" href="#customizing-ticks" title="Permalink to this headline">¶</a></h2>
<p>Matplotlib’s default tick locators and formatters are designed to be
generally sufficient in many common situations, but are in no way
optimal for every plot. This section will give several examples of
adjusting the tick locations and formatting for the particular plot type
you’re interested in.</p>
<p>Before we go into examples, it will be best for us to understand further
the object hierarchy of Matplotlib plots. Matplotlib aims to have a
Python object representing everything that appears on the plot: for
example, recall that the <code class="docutils literal notranslate"><span class="pre">figure</span></code> is the bounding box within which
plot elements appear. Each Matplotlib object can also act as a container
of sub-objects: for example, each <code class="docutils literal notranslate"><span class="pre">figure</span></code> can contain one or more
<code class="docutils literal notranslate"><span class="pre">axes</span></code> objects, each of which in turn contain other objects
representing plot contents.</p>
<p>The tick marks are no exception. Each <code class="docutils literal notranslate"><span class="pre">axes</span></code> has attributes <code class="docutils literal notranslate"><span class="pre">xaxis</span></code>
and <code class="docutils literal notranslate"><span class="pre">yaxis</span></code>, which in turn have attributes that contain all the
properties of the lines, ticks, and labels that make up the axes.</p>
<p>Within each axis, there is the concept of a <em>major</em> tick mark, and a
<em>minor</em> tick mark. As the names would imply, major ticks are usually
bigger or more pronounced, while minor ticks are usually smaller. By
default, Matplotlib rarely makes use of minor ticks, but one place you
can see them is within logarithmic plots:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import matplotlib.pyplot as plt
plt.style.use(&#39;classic&#39;)
%matplotlib inline
import numpy as np
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax = plt.axes(xscale=&#39;log&#39;, yscale=&#39;log&#39;)
ax.grid();
</pre></div>
</div>
<img alt="_images/matplotlib_221_0.png" src="_images/matplotlib_221_0.png" />
<p>We see here that each major tick shows a large tickmark and a label,
while each minor tick shows a smaller tickmark with no label.</p>
<p>These tick properties—locations and labels—that is, can be customized by
setting the <code class="docutils literal notranslate"><span class="pre">formatter</span></code> and <code class="docutils literal notranslate"><span class="pre">locator</span></code> objects of each axis. Let’s
examine these for the x axis of the just shown plot:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(ax.xaxis.get_major_locator())
print(ax.xaxis.get_minor_locator())
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">LogLocator</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7ff2b92625f8</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">LogLocator</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7ff2b92627f0</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>print(ax.xaxis.get_major_formatter())
print(ax.xaxis.get_minor_formatter())
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">LogFormatterSciNotation</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7ff2b9262828</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">ticker</span><span class="o">.</span><span class="n">LogFormatterSciNotation</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7ff2b9258c88</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>We see that both major and minor tick labels have their locations
specified by a <code class="docutils literal notranslate"><span class="pre">LogLocator</span></code> (which makes sense for a logarithmic
plot). Minor ticks, though, have their labels formatted by a
<code class="docutils literal notranslate"><span class="pre">NullFormatter</span></code>: this says that no labels will be shown.</p>
<p>Perhaps the most common tick/label formatting operation is the act of
hiding ticks or labels. This can be done using <code class="docutils literal notranslate"><span class="pre">plt.NullLocator()</span></code> and
<code class="docutils literal notranslate"><span class="pre">plt.NullFormatter()</span></code>, as shown here:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax = plt.axes()
ax.plot(np.random.rand(50))

ax.yaxis.set_major_locator(plt.NullLocator())
ax.xaxis.set_major_formatter(plt.NullFormatter())
</pre></div>
</div>
<img alt="_images/matplotlib_228_0.png" src="_images/matplotlib_228_0.png" />
<p>Notice that we’ve removed the labels (but kept the ticks/gridlines) from
the x axis, and removed the ticks (and thus the labels as well) from the
y axis. Having no ticks at all can be useful in many situations—for
example, when you want to show a grid of images. For instance, consider
the following figure, which includes images of different faces, an
example often used in supervised machine learning problems:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig, ax = plt.subplots(5, 5, figsize=(5, 5))
fig.subplots_adjust(hspace=0, wspace=0)

# Get some face data from scikit-learn
from sklearn.datasets import fetch_olivetti_faces
faces = fetch_olivetti_faces().images

for i in range(5):
    for j in range(5):
        ax[i, j].xaxis.set_major_locator(plt.NullLocator())
        ax[i, j].yaxis.set_major_locator(plt.NullLocator())
        ax[i, j].imshow(faces[10 * i + j], cmap=&quot;bone&quot;)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">downloading</span> <span class="n">Olivetti</span> <span class="n">faces</span> <span class="kn">from</span> <span class="nn">https</span><span class="p">:</span><span class="o">//</span><span class="n">ndownloader</span><span class="o">.</span><span class="n">figshare</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">files</span><span class="o">/</span><span class="mi">5976027</span> <span class="n">to</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">mn</span><span class="o">/</span><span class="n">scikit_learn_data</span>
</pre></div>
</div>
<img alt="_images/matplotlib_230_1.png" src="_images/matplotlib_230_1.png" />
<p>One common problem with the default settings is that smaller subplots
can end up with crowded labels. We can see this in the plot grid shown
here:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig, ax = plt.subplots(4, 4, sharex=True, sharey=True)
</pre></div>
</div>
<img alt="_images/matplotlib_232_0.png" src="_images/matplotlib_232_0.png" />
<p>Particularly for the x ticks, the numbers nearly overlap and make them
quite difficult to decipher. We can fix this with the
<code class="docutils literal notranslate"><span class="pre">plt.MaxNLocator()</span></code>, which allows us to specify the maximum number of
ticks that will be displayed. Given this maximum number, Matplotlib will
use internal logic to choose the particular tick locations:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># For every axis, set the x and y major locator
for axi in ax.flat:
    axi.xaxis.set_major_locator(plt.MaxNLocator(3))
    axi.yaxis.set_major_locator(plt.MaxNLocator(3))
fig
</pre></div>
</div>
<img alt="_images/matplotlib_234_0.png" src="_images/matplotlib_234_0.png" />
<p>Matplotlib’s default tick formatting can leave a lot to be desired: it
works well as a broad default, but sometimes you’d like do do something
more. Consider this plot of a sine and a cosine:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Plot a sine and cosine curve
fig, ax = plt.subplots()
x = np.linspace(0, 3 * np.pi, 1000)
ax.plot(x, np.sin(x), lw=3, label=&#39;Sine&#39;)
ax.plot(x, np.cos(x), lw=3, label=&#39;Cosine&#39;)

# Set up grid, legend, and limits
ax.grid(True)
ax.legend(frameon=False)
ax.axis(&#39;equal&#39;)
ax.set_xlim(0, 3 * np.pi);
</pre></div>
</div>
<img alt="_images/matplotlib_236_0.png" src="_images/matplotlib_236_0.png" />
<p>There are a couple changes we might like to make. First, it’s more
natural for this data to space the ticks and grid lines in multiples of
<span class="math notranslate nohighlight">\(\pi\)</span>. We can do this by setting a <code class="docutils literal notranslate"><span class="pre">MultipleLocator</span></code>, which
locates ticks at a multiple of the number you provide. For good measure,
we’ll add both major and minor ticks in multiples of <span class="math notranslate nohighlight">\(\pi/4\)</span>:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax.xaxis.set_major_locator(plt.MultipleLocator(np.pi / 2))
ax.xaxis.set_minor_locator(plt.MultipleLocator(np.pi / 4))
fig
</pre></div>
</div>
<img alt="_images/matplotlib_238_0.png" src="_images/matplotlib_238_0.png" />
<p>But now these tick labels look a little bit silly: we can see that they
are multiples of <span class="math notranslate nohighlight">\(\pi\)</span>, but the decimal representation does not
immediately convey this. To fix this, we can change the tick formatter.
There’s no built-in formatter for what we want to do, so we’ll instead
use <code class="docutils literal notranslate"><span class="pre">plt.FuncFormatter</span></code>, which accepts a user-defined function giving
fine-grained control over the tick outputs:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def format_func(value, tick_number):
    # find number of multiples of pi/2
    N = int(np.round(2 * value / np.pi))
    if N == 0:
        return &quot;0&quot;
    elif N == 1:
        return r&quot;$\pi/2$&quot;
    elif N == 2:
        return r&quot;$\pi$&quot;
    elif N % 2 &gt; 0:
        return r&quot;${0}\pi/2$&quot;.format(N)
    else:
        return r&quot;${0}\pi$&quot;.format(N // 2)

ax.xaxis.set_major_formatter(plt.FuncFormatter(format_func))
fig
</pre></div>
</div>
<img alt="_images/matplotlib_240_0.png" src="_images/matplotlib_240_0.png" />
<p>We’ve mentioned a couple of the available formatters and locators. We’ll
conclude this section by briefly listing all the built-in locator and
formatter options. For more information on any of these, refer to the
docstrings or to the Matplotlib online documentaion. Each of the
following is available in the <code class="docutils literal notranslate"><span class="pre">plt</span></code> namespace:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 62%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Locator class</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">NullLocator</span></code></p></td>
<td><p>No ticks</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">FixedLocator</span></code></p></td>
<td><p>Tick locations are fixed</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">IndexLocator</span></code></p></td>
<td><p>Locator for index plots
(e.g., where x =
range(len(y)))</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">LinearLocator</span></code></p></td>
<td><p>Evenly spaced ticks from
min to max</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">LogLocator</span></code></p></td>
<td><p>Logarithmically ticks
from min to max</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">MultipleLocator</span></code></p></td>
<td><p>Ticks and range are a
multiple of base</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">MaxNLocator</span></code></p></td>
<td><p>Finds up to a max number
of ticks at nice
locations</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">AutoLocator</span></code></p></td>
<td><p>(Default.) MaxNLocator
with simple defaults.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">AutoMinorLocator</span></code></p></td>
<td><p>Locator for minor ticks</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 36%" />
<col style="width: 64%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Formatter Class</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">NullFormatter</span></code></p></td>
<td><p>No labels on the ticks</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">IndexFormatter</span></code></p></td>
<td><p>Set the strings from a list of labels</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">FixedFormatter</span></code></p></td>
<td><p>Set the strings manually for the labels</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">FuncFormatter</span></code></p></td>
<td><p>User-defined function sets the labels</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">FormatStrFormatter</span></code></p></td>
<td><p>Use a format string for each value</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">ScalarFormatter</span></code></p></td>
<td><p>(Default.) Formatter for scalar values</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">LogFormatter</span></code></p></td>
<td><p>Default formatter for log axes</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="customizing-matplotlib-configurations-and-stylesheets">
<h2>Customizing Matplotlib: Configurations and Stylesheets<a class="headerlink" href="#customizing-matplotlib-configurations-and-stylesheets" title="Permalink to this headline">¶</a></h2>
<p>Matplotlib’s default plot settings are often the subject of complaint
among its users. While much is slated to change in the 2.0 Matplotlib
release in late 2016, the ability to customize default settings helps
bring the package inline with your own aesthetic preferences.</p>
<p>Here we’ll walk through some of Matplotlib’s runtime configuration (rc)
options, and take a look at the newer <em>stylesheets</em> feature, which
contains some nice sets of default configurations.</p>
<p>Through this chapter, we’ve seen how it is possible to tweak individual
plot settings to end up with something that looks a little bit nicer
than the default. It’s possible to do these customizations for each
individual plot. For example, here is a fairly drab default histogram:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import matplotlib.pyplot as plt
plt.style.use(&#39;classic&#39;)
import numpy as np

%matplotlib inline
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>x = np.random.randn(1000)
plt.hist(x);
</pre></div>
</div>
<img alt="_images/matplotlib_246_0.png" src="_images/matplotlib_246_0.png" />
<p>We can adjust this by hand to make it a much more visually pleasing
plot:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># use a gray background
ax = plt.axes()
ax.set_axisbelow(True)

# draw solid white grid lines
plt.grid(color=&#39;w&#39;, linestyle=&#39;solid&#39;)

# hide axis spines
for spine in ax.spines.values():
    spine.set_visible(False)

# hide top and right ticks
ax.xaxis.tick_bottom()
ax.yaxis.tick_left()

# lighten ticks and labels
ax.tick_params(colors=&#39;gray&#39;, direction=&#39;out&#39;)
for tick in ax.get_xticklabels():
    tick.set_color(&#39;gray&#39;)
for tick in ax.get_yticklabels():
    tick.set_color(&#39;gray&#39;)

# control face and edge color of histogram
ax.hist(x, edgecolor=&#39;#E6E6E6&#39;, color=&#39;#EE6666&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_248_0.png" src="_images/matplotlib_248_0.png" />
<p>Each time Matplotlib loads, it defines a runtime configuration (rc)
containing the default styles for every plot element you create. This
configuration can be adjusted at any time using the <code class="docutils literal notranslate"><span class="pre">plt.rc</span></code>
convenience routine. Let’s see what it looks like to modify the rc
parameters so that our default plot will look similar to what we did
before.</p>
<p>We’ll start by saving a copy of the current <code class="docutils literal notranslate"><span class="pre">rcParams</span></code> dictionary, so
we can easily reset these changes in the current session:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>IPython_default = plt.rcParams.copy()
</pre></div>
</div>
<p>Now we can use the <code class="docutils literal notranslate"><span class="pre">plt.rc</span></code> function to change some of these settings:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from matplotlib import cycler
colors = cycler(&#39;color&#39;,
                [&#39;#EE6666&#39;, &#39;#3388BB&#39;, &#39;#9988DD&#39;,
                 &#39;#EECC55&#39;, &#39;#88BB44&#39;, &#39;#FFBBBB&#39;])
plt.rc(&#39;axes&#39;, facecolor=&#39;#E6E6E6&#39;, edgecolor=&#39;none&#39;,
       axisbelow=True, grid=True, prop_cycle=colors)
plt.rc(&#39;grid&#39;, color=&#39;w&#39;, linestyle=&#39;solid&#39;)
plt.rc(&#39;xtick&#39;, direction=&#39;out&#39;, color=&#39;gray&#39;)
plt.rc(&#39;ytick&#39;, direction=&#39;out&#39;, color=&#39;gray&#39;)
plt.rc(&#39;patch&#39;, edgecolor=&#39;#E6E6E6&#39;)
plt.rc(&#39;lines&#39;, linewidth=2)
</pre></div>
</div>
<p>With these settings defined, we can now create a plot and see our
settings in action:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.hist(x);
</pre></div>
</div>
<img alt="_images/matplotlib_254_0.png" src="_images/matplotlib_254_0.png" />
<p>Let’s see what simple line plots look like with these rc parameters:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for i in range(4):
    plt.plot(np.random.rand(10))
</pre></div>
</div>
<img alt="_images/matplotlib_256_0.png" src="_images/matplotlib_256_0.png" />
<p>The version 1.4 release of Matplotlib in August 2014 added a very
convenient <code class="docutils literal notranslate"><span class="pre">style</span></code> module, which includes a number of new default
stylesheets, as well as the ability to create and package your own
styles. These stylesheets are formatted similarly to the <em>.matplotlibrc</em>
files mentioned earlier, but must be named with a <em>.mplstyle</em> extension.</p>
<p>Even if you don’t create your own style, the stylesheets included by
default are extremely useful. The available styles are listed in
<code class="docutils literal notranslate"><span class="pre">plt.style.available</span></code>—here I’ll list only the first five for brevity:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>plt.style.available[:5]
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;seaborn-poster&#39;</span><span class="p">,</span>
 <span class="s1">&#39;seaborn-muted&#39;</span><span class="p">,</span>
 <span class="s1">&#39;seaborn-dark-palette&#39;</span><span class="p">,</span>
 <span class="s1">&#39;seaborn-bright&#39;</span><span class="p">,</span>
 <span class="s1">&#39;seaborn-ticks&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The basic way to switch to a stylesheet is to call</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;stylename&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>But keep in mind that this will change the style for the rest of the
session! Alternatively, you can use the style context manager, which
sets a style temporarily:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="s1">&#39;stylename&#39;</span><span class="p">):</span>
    <span class="n">make_a_plot</span><span class="p">()</span>
</pre></div>
</div>
<p>Let’s create a function that will make two basic types of plot:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def hist_and_lines():
    np.random.seed(0)
    fig, ax = plt.subplots(1, 2, figsize=(11, 4))
    ax[0].hist(np.random.randn(1000))
    for i in range(3):
        ax[1].plot(np.random.rand(10))
    ax[1].legend([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], loc=&#39;lower left&#39;)
</pre></div>
</div>
<div class="section" id="default-style">
<h3>Default style<a class="headerlink" href="#default-style" title="Permalink to this headline">¶</a></h3>
<p>The default style is what we’ve been seeing so far throughout the book;
we’ll start with that. First, let’s reset our runtime configuration to
the notebook default:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># reset rcParams
plt.rcParams.update(IPython_default);
</pre></div>
</div>
<p>Now let’s see how it looks:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>hist_and_lines()
</pre></div>
</div>
<img alt="_images/matplotlib_265_0.png" src="_images/matplotlib_265_0.png" />
</div>
<div class="section" id="fivethiryeight-style">
<h3>FiveThiryEight style<a class="headerlink" href="#fivethiryeight-style" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">fivethirtyeight</span></code> style mimics the graphics found on the popular
<a class="reference external" href="https://fivethirtyeight.com">FiveThirtyEight website</a>. As you can
see here, it is typified by bold colors, thick lines, and transparent
axes:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>with plt.style.context(&#39;fivethirtyeight&#39;):
    hist_and_lines()
</pre></div>
</div>
<img alt="_images/matplotlib_267_0.png" src="_images/matplotlib_267_0.png" />
</div>
<div class="section" id="ggplot">
<h3>ggplot<a class="headerlink" href="#ggplot" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ggplot</span></code> package in the R language is a very popular visualization
tool. Matplotlib’s <code class="docutils literal notranslate"><span class="pre">ggplot</span></code> style mimics the default styles from that
package:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>with plt.style.context(&#39;ggplot&#39;):
    hist_and_lines()
</pre></div>
</div>
<img alt="_images/matplotlib_269_0.png" src="_images/matplotlib_269_0.png" />
</div>
<div class="section" id="bayesian-methods-for-hackers-style">
<h3><em>Bayesian Methods for Hackers</em> style<a class="headerlink" href="#bayesian-methods-for-hackers-style" title="Permalink to this headline">¶</a></h3>
<p>There is a very nice short online book called <a class="reference external" href="http://camdavidsonpilon.github.io/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/">Probabilistic Programming
and Bayesian Methods for
Hackers</a>;
it features figures created with Matplotlib, and uses a nice set of rc
parameters to create a consistent and visually-appealing style
throughout the book. This style is reproduced in the <code class="docutils literal notranslate"><span class="pre">bmh</span></code> stylesheet:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>with plt.style.context(&#39;bmh&#39;):
    hist_and_lines()
</pre></div>
</div>
<img alt="_images/matplotlib_271_0.png" src="_images/matplotlib_271_0.png" />
</div>
<div class="section" id="seaborn-style">
<h3>Seaborn style<a class="headerlink" href="#seaborn-style" title="Permalink to this headline">¶</a></h3>
<p>Matplotlib also has stylesheets inspired by the Seaborn library. As we
will see, these styles are loaded automatically when Seaborn is imported
into a notebook. I’ve found these settings to be very nice, and tend to
use them as defaults in my own data exploration.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import seaborn
hist_and_lines()
</pre></div>
</div>
<img alt="_images/matplotlib_273_0.png" src="_images/matplotlib_273_0.png" />
</div>
</div>
<div class="section" id="three-dimensional-plotting-in-matplotlib">
<h2>Three-Dimensional Plotting in Matplotlib<a class="headerlink" href="#three-dimensional-plotting-in-matplotlib" title="Permalink to this headline">¶</a></h2>
<p>Matplotlib was initially designed with only two-dimensional plotting in
mind. Around the time of the 1.0 release, some three-dimensional
plotting utilities were built on top of Matplotlib’s two-dimensional
display, and the result is a convenient (if somewhat limited) set of
tools for three-dimensional data visualization. three-dimensional plots
are enabled by importing the <code class="docutils literal notranslate"><span class="pre">mplot3d</span></code> toolkit, included with the main
Matplotlib installation:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from mpl_toolkits import mplot3d
</pre></div>
</div>
<p>Once this submodule is imported, a three-dimensional axes can be created
by passing the keyword <code class="docutils literal notranslate"><span class="pre">projection='3d'</span></code> to any of the normal axes
creation routines:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%matplotlib inline
import numpy as np
import matplotlib.pyplot as plt
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = plt.figure()
ax = plt.axes(projection=&#39;3d&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_278_0.png" src="_images/matplotlib_278_0.png" />
<p>With this three-dimensional axes enabled, we can now plot a variety of
three-dimensional plot types. Three-dimensional plotting is one of the
functionalities that benefits immensely from viewing figures
interactively rather than statically in the notebook; recall that to use
interactive figures, you can use <code class="docutils literal notranslate"><span class="pre">%matplotlib</span> <span class="pre">notebook</span></code> rather than
<code class="docutils literal notranslate"><span class="pre">%matplotlib</span> <span class="pre">inline</span></code> when running this code.</p>
<p>The most basic three-dimensional plot is a line or collection of scatter
plot created from sets of (x, y, z) triples. In analogy with the more
common two-dimensional plots discussed earlier, these can be created
using the <code class="docutils literal notranslate"><span class="pre">ax.plot3D</span></code> and <code class="docutils literal notranslate"><span class="pre">ax.scatter3D</span></code> functions. The call
signature for these is nearly identical to that of their two-dimensional
counterparts, so you can refer to <a class="reference external" href="04.01-Simple-Line-Plots.ipynb">Simple Line
Plots</a> and <a class="reference external" href="04.02-Simple-Scatter-Plots.ipynb">Simple Scatter
Plots</a> for more information on
controlling the output.</p>
<p>Here we’ll plot a trigonometric spiral, along with some points drawn
randomly near the line:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax = plt.axes(projection=&#39;3d&#39;)

# Data for a three-dimensional line
zline = np.linspace(0, 15, 1000)
xline = np.sin(zline)
yline = np.cos(zline)
ax.plot3D(xline, yline, zline, &#39;gray&#39;)

# Data for three-dimensional scattered points
zdata = 15 * np.random.random(100)
xdata = np.sin(zdata) + 0.1 * np.random.randn(100)
ydata = np.cos(zdata) + 0.1 * np.random.randn(100)
ax.scatter3D(xdata, ydata, zdata, c=zdata, cmap=&#39;Greens&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_282_0.png" src="_images/matplotlib_282_0.png" />
<p>Analogous to the contour plots contains tools to create
three-dimensional relief plots using the same inputs. Like
two-dimensional <code class="docutils literal notranslate"><span class="pre">ax.contour</span></code> plots, <code class="docutils literal notranslate"><span class="pre">ax.contour3D</span></code> requires all the
input data to be in the form of two-dimensional regular grids, with the
Z data evaluated at each point. Here we’ll show a three-dimensional
contour diagram of a three-dimensional sinusoidal function:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def f(x, y):
    return np.sin(np.sqrt(x ** 2 + y ** 2))

x = np.linspace(-6, 6, 30)
y = np.linspace(-6, 6, 30)

X, Y = np.meshgrid(x, y)
Z = f(X, Y)
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = plt.figure()
ax = plt.axes(projection=&#39;3d&#39;)
ax.contour3D(X, Y, Z, 50, cmap=&#39;binary&#39;)
ax.set_xlabel(&#39;x&#39;)
ax.set_ylabel(&#39;y&#39;)
ax.set_zlabel(&#39;z&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_285_0.png" src="_images/matplotlib_285_0.png" />
<p>Sometimes the default viewing angle is not optimal, in which case we can
use the <code class="docutils literal notranslate"><span class="pre">view_init</span></code> method to set the elevation and azimuthal angles.
In the following example, we’ll use an elevation of 60 degrees (that is,
60 degrees above the x-y plane) and an azimuth of 35 degrees (that is,
rotated 35 degrees counter-clockwise about the z-axis):</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax.view_init(60, 35)
fig
</pre></div>
</div>
<img alt="_images/matplotlib_287_0.png" src="_images/matplotlib_287_0.png" />
<p>Two other types of three-dimensional plots that work on gridded data are
wireframes and surface plots. These take a grid of values and project it
onto the specified three-dimensional surface, and can make the resulting
three-dimensional forms quite easy to visualize. Here’s an example of
using a wireframe:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = plt.figure()
ax = plt.axes(projection=&#39;3d&#39;)
ax.plot_wireframe(X, Y, Z, color=&#39;black&#39;)
ax.set_title(&#39;wireframe&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_289_0.png" src="_images/matplotlib_289_0.png" />
<p>A surface plot is like a wireframe plot, but each face of the wireframe
is a filled polygon. Adding a colormap to the filled polygons can aid
perception of the topology of the surface being visualized:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax = plt.axes(projection=&#39;3d&#39;)
ax.plot_surface(X, Y, Z, rstride=1, cstride=1,
                cmap=&#39;viridis&#39;, edgecolor=&#39;none&#39;)
ax.set_title(&#39;surface&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_291_0.png" src="_images/matplotlib_291_0.png" />
<p>Note that though the grid of values for a surface plot needs to be
two-dimensional, it need not be rectilinear. Here is an example of
creating a partial polar grid, which when used with the <code class="docutils literal notranslate"><span class="pre">surface3D</span></code>
plot can give us a slice into the function we’re visualizing:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>r = np.linspace(0, 6, 20)
theta = np.linspace(-0.9 * np.pi, 0.8 * np.pi, 40)
r, theta = np.meshgrid(r, theta)

X = r * np.sin(theta)
Y = r * np.cos(theta)
Z = f(X, Y)

ax = plt.axes(projection=&#39;3d&#39;)
ax.plot_surface(X, Y, Z, rstride=1, cstride=1,
                cmap=&#39;viridis&#39;, edgecolor=&#39;none&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_293_0.png" src="_images/matplotlib_293_0.png" />
<p>For some applications, the evenly sampled grids required by the above
routines is overly restrictive and inconvenient. In these situations,
the triangulation-based plots can be very useful. What if rather than an
even draw from a Cartesian or a polar grid, we instead have a set of
random draws?</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>theta = 2 * np.pi * np.random.random(1000)
r = 6 * np.random.random(1000)
x = np.ravel(r * np.sin(theta))
y = np.ravel(r * np.cos(theta))
z = f(x, y)
</pre></div>
</div>
<p>We could create a scatter plot of the points to get an idea of the
surface we’re sampling from:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax = plt.axes(projection=&#39;3d&#39;)
ax.scatter(x, y, z, c=z, cmap=&#39;viridis&#39;, linewidth=0.5);
</pre></div>
</div>
<img alt="_images/matplotlib_297_0.png" src="_images/matplotlib_297_0.png" />
<p>This leaves a lot to be desired. The function that will help us in this
case is <code class="docutils literal notranslate"><span class="pre">ax.plot_trisurf</span></code>, which creates a surface by first finding a
set of triangles formed between adjacent points (remember that x, y, and
z here are one-dimensional arrays):</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>ax = plt.axes(projection=&#39;3d&#39;)
ax.plot_trisurf(x, y, z,
                cmap=&#39;viridis&#39;, edgecolor=&#39;none&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_299_0.png" src="_images/matplotlib_299_0.png" />
<div class="section" id="example-visualizing-a-mobius-strip">
<h3>Example: Visualizing a Möbius strip<a class="headerlink" href="#example-visualizing-a-mobius-strip" title="Permalink to this headline">¶</a></h3>
<p>A Möbius strip is similar to a strip of paper glued into a loop with a
half-twist. Topologically, it’s quite interesting because despite
appearances it has only a single side! Here we will visualize such an
object using Matplotlib’s three-dimensional tools. The key to creating
the Möbius strip is to think about it’s parametrization: it’s a
two-dimensional strip, so we need two intrinsic dimensions. Let’s call
them <span class="math notranslate nohighlight">\(\theta\)</span>, which ranges from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(2\pi\)</span> around
the loop, and <span class="math notranslate nohighlight">\(w\)</span> which ranges from -1 to 1 across the width of
the strip:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>theta = np.linspace(0, 2 * np.pi, 30)
w = np.linspace(-0.25, 0.25, 8)
w, theta = np.meshgrid(w, theta)
</pre></div>
</div>
<p>Now from this parametrization, we must determine the <em>(x, y, z)</em>
positions of the embedded strip.</p>
<p>Thinking about it, we might realize that there are two rotations
happening: one is the position of the loop about its center (what we’ve
called <span class="math notranslate nohighlight">\(\theta\)</span>), while the other is the twisting of the strip
about its axis (we’ll call this <span class="math notranslate nohighlight">\(\phi\)</span>). For a Möbius strip, we
must have the strip makes half a twist during a full loop, or
<span class="math notranslate nohighlight">\(\Delta\phi = \Delta\theta/2\)</span>.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>phi = 0.5 * theta
</pre></div>
</div>
<p>Now we use our recollection of trigonometry to derive the
three-dimensional embedding. We’ll define <span class="math notranslate nohighlight">\(r\)</span>, the distance of
each point from the center, and use this to find the embedded
<span class="math notranslate nohighlight">\((x, y, z)\)</span> coordinates:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># radius in x-y plane
r = 1 + w * np.cos(phi)

x = np.ravel(r * np.cos(theta))
y = np.ravel(r * np.sin(theta))
z = np.ravel(w * np.sin(phi))
</pre></div>
</div>
<p>Finally, to plot the object, we must make sure the triangulation is
correct. The best way to do this is to define the triangulation <em>within
the underlying parametrization</em>, and then let Matplotlib project this
triangulation into the three-dimensional space of the Möbius strip. This
can be accomplished as follows:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># triangulate in the underlying parametrization
from matplotlib.tri import Triangulation
tri = Triangulation(np.ravel(w), np.ravel(theta))

ax = plt.axes(projection=&#39;3d&#39;)
ax.plot_trisurf(x, y, z, triangles=tri.triangles,
                cmap=&#39;viridis&#39;, linewidths=0.2);

ax.set_xlim(-1, 1); ax.set_ylim(-1, 1); ax.set_zlim(-1, 1);
</pre></div>
</div>
<img alt="_images/matplotlib_307_0.png" src="_images/matplotlib_307_0.png" />
</div>
</div>
<div class="section" id="visualization-with-seaborn">
<h2>Visualization with Seaborn<a class="headerlink" href="#visualization-with-seaborn" title="Permalink to this headline">¶</a></h2>
<p>Matplotlib has proven to be an incredibly useful and popular
visualization tool, but even avid users will admit it often leaves much
to be desired. There are several valid complaints about Matplotlib that
often come up:</p>
<ul class="simple">
<li><p>Prior to version 2.0, Matplotlib’s defaults are not exactly the best
choices. It was based off of MATLAB circa 1999, and this often shows.</p></li>
<li><p>Matplotlib’s API is relatively low level. Doing sophisticated
statistical visualization is possible, but often requires a <em>lot</em> of
boilerplate code.</p></li>
<li><p>Matplotlib predated Pandas by more than a decade, and thus is not
designed for use with Pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>s. In order to visualize
data from a Pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, you must extract each <code class="docutils literal notranslate"><span class="pre">Series</span></code>
and often concatenate them together into the right format. It would
be nicer to have a plotting library that can intelligently use the
<code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> labels in a plot.</p></li>
</ul>
<p>An answer to these problems is <a class="reference external" href="http://seaborn.pydata.org/">Seaborn</a>.
Seaborn provides an API on top of Matplotlib that offers sane choices
for plot style and color defaults, defines simple high-level functions
for common statistical plot types, and integrates with the functionality
provided by Pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>s.</p>
<p>To be fair, the Matplotlib team is addressing this: it has recently
added the <code class="docutils literal notranslate"><span class="pre">plt.style</span></code> tools, and is starting to handle Pandas data
more seamlessly. The 2.0 release of the library will include a new
default stylesheet that will improve on the current status quo. But for
all the reasons just discussed, Seaborn remains an extremely useful
addon.</p>
<p>Here is an example of a simple random-walk plot in Matplotlib, using its
classic plot formatting and colors. We start with the typical imports:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import matplotlib.pyplot as plt
plt.style.use(&#39;classic&#39;)
%matplotlib inline
import numpy as np
import pandas as pd
</pre></div>
</div>
<p>Now we create some random walk data:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Create some data
rng = np.random.RandomState(0)
x = np.linspace(0, 10, 500)
y = np.cumsum(rng.randn(500, 6), 0)
</pre></div>
</div>
<p>And do a simple plot:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Plot the data with Matplotlib defaults
plt.plot(x, y)
plt.legend(&#39;ABCDEF&#39;, ncol=2, loc=&#39;upper left&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_315_0.png" src="_images/matplotlib_315_0.png" />
<p>Although the result contains all the information we’d like it to convey,
it does so in a way that is not all that aesthetically pleasing, and
even looks a bit old-fashioned in the context of 21st-century data
visualization.</p>
<p>Now let’s take a look at how it works with Seaborn. As we will see,
Seaborn has many of its own high-level plotting routines, but it can
also overwrite Matplotlib’s default parameters and in turn get even
simple Matplotlib scripts to produce vastly superior output. We can set
the style by calling Seaborn’s <code class="docutils literal notranslate"><span class="pre">set()</span></code> method. By convention, Seaborn
is imported as <code class="docutils literal notranslate"><span class="pre">sns</span></code>:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import seaborn as sns
sns.set()
</pre></div>
</div>
<p>Now let’s rerun the same two lines as before:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># same plotting code as above!
plt.plot(x, y)
plt.legend(&#39;ABCDEF&#39;, ncol=2, loc=&#39;upper left&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_319_0.png" src="_images/matplotlib_319_0.png" />
<p>The main idea of Seaborn is that it provides high-level commands to
create a variety of plot types useful for statistical data exploration,
and even some statistical model fitting.</p>
<p>Let’s take a look at a few of the datasets and plot types available in
Seaborn. Note that all of the following <em>could</em> be done using raw
Matplotlib commands (this is, in fact, what Seaborn does under the hood)
but the Seaborn API is much more convenient.</p>
<div class="section" id="histograms-kde-and-densities">
<h3>Histograms, KDE, and densities<a class="headerlink" href="#histograms-kde-and-densities" title="Permalink to this headline">¶</a></h3>
<p>Often in statistical data visualization, all you want is to plot
histograms and joint distributions of variables. We have seen that this
is relatively straightforward in Matplotlib:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>data = np.random.multivariate_normal([0, 0], [[5, 2], [2, 2]], size=2000)
data = pd.DataFrame(data, columns=[&#39;x&#39;, &#39;y&#39;])

for col in &#39;xy&#39;:
    plt.hist(data[col], density=True, alpha=0.5)
</pre></div>
</div>
<img alt="_images/matplotlib_322_0.png" src="_images/matplotlib_322_0.png" />
<p>Rather than a histogram, we can get a smooth estimate of the
distribution using a kernel density estimation, which Seaborn does with
<code class="docutils literal notranslate"><span class="pre">sns.kdeplot</span></code>:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>for col in &#39;xy&#39;:
    sns.kdeplot(data[col], shade=True)
</pre></div>
</div>
<img alt="_images/matplotlib_324_0.png" src="_images/matplotlib_324_0.png" />
<p>Histograms and KDE can be combined using <code class="docutils literal notranslate"><span class="pre">distplot</span></code>:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>sns.distplot(data[&#39;x&#39;])
sns.distplot(data[&#39;y&#39;]);
</pre></div>
</div>
<img alt="_images/matplotlib_326_0.png" src="_images/matplotlib_326_0.png" />
<p>If we pass the full two-dimensional dataset to <code class="docutils literal notranslate"><span class="pre">kdeplot</span></code>, we will get
a two-dimensional visualization of the data:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>sns.kdeplot(data);
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">mn</span><span class="o">/</span><span class="n">Developer</span><span class="o">/</span><span class="n">working</span><span class="o">-</span><span class="n">copies</span><span class="o">/</span><span class="n">pythons</span><span class="o">/</span><span class="n">venv</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">python3</span><span class="o">.</span><span class="mi">7</span><span class="o">/</span><span class="n">site</span><span class="o">-</span><span class="n">packages</span><span class="o">/</span><span class="n">seaborn</span><span class="o">/</span><span class="n">distributions</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">693</span><span class="p">:</span> <span class="ne">UserWarning</span><span class="p">:</span> <span class="n">Passing</span> <span class="n">a</span> <span class="mi">2</span><span class="n">D</span> <span class="n">dataset</span> <span class="k">for</span> <span class="n">a</span> <span class="n">bivariate</span> <span class="n">plot</span> <span class="ow">is</span> <span class="n">deprecated</span> <span class="ow">in</span> <span class="n">favor</span> <span class="n">of</span> <span class="n">kdeplot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="ow">and</span> <span class="n">it</span> <span class="n">will</span> <span class="n">cause</span> <span class="n">an</span> <span class="n">error</span> <span class="ow">in</span> <span class="n">future</span> <span class="n">versions</span><span class="o">.</span> <span class="n">Please</span> <span class="n">update</span> <span class="n">your</span> <span class="n">code</span><span class="o">.</span>
  <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">warn_msg</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
</pre></div>
</div>
<img alt="_images/matplotlib_328_1.png" src="_images/matplotlib_328_1.png" />
<p>We can see the joint distribution and the marginal distributions
together using <code class="docutils literal notranslate"><span class="pre">sns.jointplot</span></code>. For this plot, we’ll set the style to
a white background:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>with sns.axes_style(&#39;white&#39;):
    sns.jointplot(&quot;x&quot;, &quot;y&quot;, data, kind=&#39;kde&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_330_0.png" src="_images/matplotlib_330_0.png" />
<p>There are other parameters that can be passed to <code class="docutils literal notranslate"><span class="pre">jointplot</span></code>—for
example, we can use a hexagonally based histogram instead:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>with sns.axes_style(&#39;white&#39;):
    sns.jointplot(&quot;x&quot;, &quot;y&quot;, data, kind=&#39;hex&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_332_0.png" src="_images/matplotlib_332_0.png" />
</div>
<div class="section" id="pair-plots">
<h3>Pair plots<a class="headerlink" href="#pair-plots" title="Permalink to this headline">¶</a></h3>
<p>When you generalize joint plots to datasets of larger dimensions, you
end up with <em>pair plots</em>. This is very useful for exploring correlations
between multidimensional data, when you’d like to plot all pairs of
values against each other.</p>
<p>We’ll demo this with the well-known Iris dataset, which lists
measurements of petals and sepals of three iris species:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>iris = sns.load_dataset(&quot;iris&quot;)
iris.head()
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>sepal_length</th>
      <th>sepal_width</th>
      <th>petal_length</th>
      <th>petal_width</th>
      <th>species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.6</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.0</td>
      <td>3.6</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>setosa</td>
    </tr>
  </tbody>
</table>
</div><p>Visualizing the multidimensional relationships among the samples is as
easy as calling <code class="docutils literal notranslate"><span class="pre">sns.pairplot</span></code>:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>sns.pairplot(iris, hue=&#39;species&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_336_0.png" src="_images/matplotlib_336_0.png" />
</div>
<div class="section" id="faceted-histograms">
<h3>Faceted histograms<a class="headerlink" href="#faceted-histograms" title="Permalink to this headline">¶</a></h3>
<p>Sometimes the best way to view data is via histograms of subsets.
Seaborn’s <code class="docutils literal notranslate"><span class="pre">FacetGrid</span></code> makes this extremely simple. We’ll take a look
at some data that shows the amount that restaurant staff receive in tips
based on various indicator data:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>tips = sns.load_dataset(&#39;tips&#39;)
tips.head()
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>total_bill</th>
      <th>tip</th>
      <th>sex</th>
      <th>smoker</th>
      <th>day</th>
      <th>time</th>
      <th>size</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>16.99</td>
      <td>1.01</td>
      <td>Female</td>
      <td>No</td>
      <td>Sun</td>
      <td>Dinner</td>
      <td>2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>10.34</td>
      <td>1.66</td>
      <td>Male</td>
      <td>No</td>
      <td>Sun</td>
      <td>Dinner</td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>21.01</td>
      <td>3.50</td>
      <td>Male</td>
      <td>No</td>
      <td>Sun</td>
      <td>Dinner</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>23.68</td>
      <td>3.31</td>
      <td>Male</td>
      <td>No</td>
      <td>Sun</td>
      <td>Dinner</td>
      <td>2</td>
    </tr>
    <tr>
      <th>4</th>
      <td>24.59</td>
      <td>3.61</td>
      <td>Female</td>
      <td>No</td>
      <td>Sun</td>
      <td>Dinner</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div><div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>tips[&#39;tip_pct&#39;] = 100 * tips[&#39;tip&#39;] / tips[&#39;total_bill&#39;]

grid = sns.FacetGrid(tips, row=&quot;sex&quot;, col=&quot;time&quot;, margin_titles=True)
grid.map(plt.hist, &quot;tip_pct&quot;, bins=np.linspace(0, 40, 15));
</pre></div>
</div>
<img alt="_images/matplotlib_339_0.png" src="_images/matplotlib_339_0.png" />
</div>
<div class="section" id="factor-plots">
<h3>Factor plots<a class="headerlink" href="#factor-plots" title="Permalink to this headline">¶</a></h3>
<p>Factor plots can be useful for this kind of visualization as well. This
allows you to view the distribution of a parameter within bins defined
by any other parameter:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>with sns.axes_style(style=&#39;ticks&#39;):
    g = sns.catplot(&quot;day&quot;, &quot;total_bill&quot;, &quot;sex&quot;, data=tips, kind=&quot;box&quot;)
    g.set_axis_labels(&quot;Day&quot;, &quot;Total Bill&quot;);
</pre></div>
</div>
<img alt="_images/matplotlib_341_0.png" src="_images/matplotlib_341_0.png" />
</div>
<div class="section" id="joint-distributions">
<h3>Joint distributions<a class="headerlink" href="#joint-distributions" title="Permalink to this headline">¶</a></h3>
<p>Similar to the pairplot we saw earlier, we can use <code class="docutils literal notranslate"><span class="pre">sns.jointplot</span></code> to
show the joint distribution between different datasets, along with the
associated marginal distributions:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>with sns.axes_style(&#39;white&#39;):
    sns.jointplot(&quot;total_bill&quot;, &quot;tip&quot;, data=tips, kind=&#39;hex&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_343_0.png" src="_images/matplotlib_343_0.png" />
<p>The joint plot can even do some automatic kernel density estimation and
regression:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>sns.jointplot(&quot;total_bill&quot;, &quot;tip&quot;, data=tips, kind=&#39;reg&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_345_0.png" src="_images/matplotlib_345_0.png" />
</div>
<div class="section" id="bar-plots">
<h3>Bar plots<a class="headerlink" href="#bar-plots" title="Permalink to this headline">¶</a></h3>
<p>Time series can be plotted using <code class="docutils literal notranslate"><span class="pre">sns.factorplot</span></code>. In the following
example, we’ll use the Planets data:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>planets = sns.load_dataset(&#39;planets&#39;)
planets.head()
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>method</th>
      <th>number</th>
      <th>orbital_period</th>
      <th>mass</th>
      <th>distance</th>
      <th>year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>269.300</td>
      <td>7.10</td>
      <td>77.40</td>
      <td>2006</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>874.774</td>
      <td>2.21</td>
      <td>56.95</td>
      <td>2008</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>763.000</td>
      <td>2.60</td>
      <td>19.84</td>
      <td>2011</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>326.030</td>
      <td>19.40</td>
      <td>110.62</td>
      <td>2007</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>516.220</td>
      <td>10.50</td>
      <td>119.47</td>
      <td>2009</td>
    </tr>
  </tbody>
</table>
</div><div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>with sns.axes_style(&#39;white&#39;):
    g = sns.catplot(&quot;year&quot;, data=planets, aspect=2,
                       kind=&quot;count&quot;, color=&#39;steelblue&#39;)
    g.set_xticklabels(step=5)
</pre></div>
</div>
<img alt="_images/matplotlib_348_0.png" src="_images/matplotlib_348_0.png" />
<p>We can learn more by looking at the <em>method</em> of discovery of each of
these planets:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>with sns.axes_style(&#39;white&#39;):
    g = sns.factorplot(&quot;year&quot;, data=planets, aspect=4.0, kind=&#39;count&#39;,
                       hue=&#39;method&#39;, order=range(2001, 2015))
    g.set_ylabels(&#39;Number of Planets Discovered&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_350_0.png" src="_images/matplotlib_350_0.png" />
<div class="section" id="example-exploring-marathon-finishing-times">
<h4>Example: Exploring Marathon Finishing Times<a class="headerlink" href="#example-exploring-marathon-finishing-times" title="Permalink to this headline">¶</a></h4>
<p>Here we’ll look at using Seaborn to help visualize and understand
finishing results from a marathon. I’ve scraped the data from sources on
the Web, aggregated it and removed any identifying information, and put
it on GitHub where it can be downloaded (if you are interested in using
Python for web scraping, I would recommend <a class="reference external" href="http://shop.oreilly.com/product/0636920034391.do">Web Scraping with
Python</a> by Ryan
Mitchell). We will start by downloading the data from the Web, and
loading it into Pandas:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>!curl -O https://raw.githubusercontent.com/jakevdp/marathon-data/master/marathon-data.csv
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">%</span> <span class="n">Total</span>    <span class="o">%</span> <span class="n">Received</span> <span class="o">%</span> <span class="n">Xferd</span>  <span class="n">Average</span> <span class="n">Speed</span>   <span class="n">Time</span>    <span class="n">Time</span>     <span class="n">Time</span>  <span class="n">Current</span>
                                 <span class="n">Dload</span>  <span class="n">Upload</span>   <span class="n">Total</span>   <span class="n">Spent</span>    <span class="n">Left</span>  <span class="n">Speed</span>
<span class="mi">100</span>  <span class="mi">836</span><span class="n">k</span>  <span class="mi">100</span>  <span class="mi">836</span><span class="n">k</span>    <span class="mi">0</span>     <span class="mi">0</span>   <span class="mi">974</span><span class="n">k</span>      <span class="mi">0</span> <span class="o">--</span><span class="p">:</span><span class="o">--</span><span class="p">:</span><span class="o">--</span> <span class="o">--</span><span class="p">:</span><span class="o">--</span><span class="p">:</span><span class="o">--</span> <span class="o">--</span><span class="p">:</span><span class="o">--</span><span class="p">:</span><span class="o">--</span>  <span class="mi">972</span><span class="n">k</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>data = pd.read_csv(&#39;marathon-data.csv&#39;)
data.head()
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>gender</th>
      <th>split</th>
      <th>final</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>33</td>
      <td>M</td>
      <td>01:05:38</td>
      <td>02:08:51</td>
    </tr>
    <tr>
      <th>1</th>
      <td>32</td>
      <td>M</td>
      <td>01:06:26</td>
      <td>02:09:28</td>
    </tr>
    <tr>
      <th>2</th>
      <td>31</td>
      <td>M</td>
      <td>01:06:49</td>
      <td>02:10:42</td>
    </tr>
    <tr>
      <th>3</th>
      <td>38</td>
      <td>M</td>
      <td>01:06:16</td>
      <td>02:13:45</td>
    </tr>
    <tr>
      <th>4</th>
      <td>31</td>
      <td>M</td>
      <td>01:06:32</td>
      <td>02:13:59</td>
    </tr>
  </tbody>
</table>
</div><p>By default, Pandas loaded the time columns as Python strings (type
<code class="docutils literal notranslate"><span class="pre">object</span></code>); we can see this by looking at the <code class="docutils literal notranslate"><span class="pre">dtypes</span></code> attribute of
the DataFrame:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>data.dtypes
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">age</span>        <span class="n">int64</span>
<span class="n">gender</span>    <span class="nb">object</span>
<span class="n">split</span>     <span class="nb">object</span>
<span class="n">final</span>     <span class="nb">object</span>
<span class="n">dtype</span><span class="p">:</span> <span class="nb">object</span>
</pre></div>
</div>
<p>Let’s fix this by providing a converter for the times:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>import datetime

def convert_time(s):
    h, m, s = map(int, s.split(&#39;:&#39;))
    return datetime.timedelta(hours=h, minutes=m, seconds=s)

data = pd.read_csv(&#39;marathon-data.csv&#39;,
                   converters={&#39;split&#39;:convert_time, &#39;final&#39;:convert_time})
data.head()
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>gender</th>
      <th>split</th>
      <th>final</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>33</td>
      <td>M</td>
      <td>01:05:38</td>
      <td>02:08:51</td>
    </tr>
    <tr>
      <th>1</th>
      <td>32</td>
      <td>M</td>
      <td>01:06:26</td>
      <td>02:09:28</td>
    </tr>
    <tr>
      <th>2</th>
      <td>31</td>
      <td>M</td>
      <td>01:06:49</td>
      <td>02:10:42</td>
    </tr>
    <tr>
      <th>3</th>
      <td>38</td>
      <td>M</td>
      <td>01:06:16</td>
      <td>02:13:45</td>
    </tr>
    <tr>
      <th>4</th>
      <td>31</td>
      <td>M</td>
      <td>01:06:32</td>
      <td>02:13:59</td>
    </tr>
  </tbody>
</table>
</div><div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>data.dtypes
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">age</span>                 <span class="n">int64</span>
<span class="n">gender</span>             <span class="nb">object</span>
<span class="n">split</span>     <span class="n">timedelta64</span><span class="p">[</span><span class="n">ns</span><span class="p">]</span>
<span class="n">final</span>     <span class="n">timedelta64</span><span class="p">[</span><span class="n">ns</span><span class="p">]</span>
<span class="n">dtype</span><span class="p">:</span> <span class="nb">object</span>
</pre></div>
</div>
<p>That looks much better. For the purpose of our Seaborn plotting
utilities, let’s next add columns that give the times in seconds:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>data[&#39;split_sec&#39;] = data[&#39;split&#39;].astype(int) / 1E9
data[&#39;final_sec&#39;] = data[&#39;final&#39;].astype(int) / 1E9
data.head()
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>gender</th>
      <th>split</th>
      <th>final</th>
      <th>split_sec</th>
      <th>final_sec</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>33</td>
      <td>M</td>
      <td>01:05:38</td>
      <td>02:08:51</td>
      <td>3938.0</td>
      <td>7731.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>32</td>
      <td>M</td>
      <td>01:06:26</td>
      <td>02:09:28</td>
      <td>3986.0</td>
      <td>7768.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>31</td>
      <td>M</td>
      <td>01:06:49</td>
      <td>02:10:42</td>
      <td>4009.0</td>
      <td>7842.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>38</td>
      <td>M</td>
      <td>01:06:16</td>
      <td>02:13:45</td>
      <td>3976.0</td>
      <td>8025.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>31</td>
      <td>M</td>
      <td>01:06:32</td>
      <td>02:13:59</td>
      <td>3992.0</td>
      <td>8039.0</td>
    </tr>
  </tbody>
</table>
</div><p>To get an idea of what the data looks like, we can plot a <code class="docutils literal notranslate"><span class="pre">jointplot</span></code>
over the data:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>with sns.axes_style(&#39;white&#39;):
    g = sns.jointplot(&quot;split_sec&quot;, &quot;final_sec&quot;, data, kind=&#39;hex&#39;)
    g.ax_joint.plot(np.linspace(4000, 16000),
                    np.linspace(8000, 32000), &#39;:k&#39;)
</pre></div>
</div>
<img alt="_images/matplotlib_362_0.png" src="_images/matplotlib_362_0.png" />
<p>The dotted line shows where someone’s time would lie if they ran the
marathon at a perfectly steady pace. The fact that the distribution lies
above this indicates (as you might expect) that most people slow down
over the course of the marathon. If you have run competitively, you’ll
know that those who do the opposite—run faster during the second half of
the race—are said to have “negative-split” the race.</p>
<p>Let’s create another column in the data, the split fraction, which
measures the degree to which each runner negative-splits or
positive-splits the race:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>data[&#39;split_frac&#39;] = 1 - 2 * data[&#39;split_sec&#39;] / data[&#39;final_sec&#39;]
data.head()
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>gender</th>
      <th>split</th>
      <th>final</th>
      <th>split_sec</th>
      <th>final_sec</th>
      <th>split_frac</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>33</td>
      <td>M</td>
      <td>01:05:38</td>
      <td>02:08:51</td>
      <td>3938.0</td>
      <td>7731.0</td>
      <td>-0.018756</td>
    </tr>
    <tr>
      <th>1</th>
      <td>32</td>
      <td>M</td>
      <td>01:06:26</td>
      <td>02:09:28</td>
      <td>3986.0</td>
      <td>7768.0</td>
      <td>-0.026262</td>
    </tr>
    <tr>
      <th>2</th>
      <td>31</td>
      <td>M</td>
      <td>01:06:49</td>
      <td>02:10:42</td>
      <td>4009.0</td>
      <td>7842.0</td>
      <td>-0.022443</td>
    </tr>
    <tr>
      <th>3</th>
      <td>38</td>
      <td>M</td>
      <td>01:06:16</td>
      <td>02:13:45</td>
      <td>3976.0</td>
      <td>8025.0</td>
      <td>0.009097</td>
    </tr>
    <tr>
      <th>4</th>
      <td>31</td>
      <td>M</td>
      <td>01:06:32</td>
      <td>02:13:59</td>
      <td>3992.0</td>
      <td>8039.0</td>
      <td>0.006842</td>
    </tr>
  </tbody>
</table>
</div><p>Where this split difference is less than zero, the person negative-split
the race by that fraction. Let’s do a distribution plot of this split
fraction:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>sns.distplot(data[&#39;split_frac&#39;], kde=False);
plt.axvline(0, color=&quot;k&quot;, linestyle=&quot;--&quot;);
</pre></div>
</div>
<img alt="_images/matplotlib_366_0.png" src="_images/matplotlib_366_0.png" />
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>sum(data.split_frac &lt; 0)
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">251</span>
</pre></div>
</div>
<p>Out of nearly 40,000 participants, there were only 250 people who
negative-split their marathon.</p>
<p>Let’s see whether there is any correlation between this split fraction
and other variables. We’ll do this using a <code class="docutils literal notranslate"><span class="pre">pairgrid</span></code>, which draws
plots of all these correlations:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>g = sns.PairGrid(data, vars=[&#39;age&#39;, &#39;split_sec&#39;, &#39;final_sec&#39;, &#39;split_frac&#39;],
                 hue=&#39;gender&#39;, palette=&#39;RdBu_r&#39;)
g.map(plt.scatter, alpha=0.8)
g.add_legend();
</pre></div>
</div>
<img alt="_images/matplotlib_369_0.png" src="_images/matplotlib_369_0.png" />
<p>It looks like the split fraction does not correlate particularly with
age, but does correlate with the final time: faster runners tend to have
closer to even splits on their marathon time. (We see here that Seaborn
is no panacea for Matplotlib’s ills when it comes to plot styles: in
particular, the x-axis labels overlap. Because the output is a simple
Matplotlib plot, however, the methods about ticks can be used to adjust
such things if desired.)</p>
<p>The difference between men and women here is interesting. Let’s look at
the histogram of split fractions for these two groups:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>sns.kdeplot(data.split_frac[data.gender==&#39;M&#39;], label=&#39;men&#39;, shade=True)
sns.kdeplot(data.split_frac[data.gender==&#39;W&#39;], label=&#39;women&#39;, shade=True)
plt.xlabel(&#39;split_frac&#39;);
</pre></div>
</div>
<img alt="_images/matplotlib_372_0.png" src="_images/matplotlib_372_0.png" />
<p>The interesting thing here is that there are many more men than women
who are running close to an even split! This almost looks like some kind
of bimodal distribution among the men and women. Let’s see if we can
suss-out what’s going on by looking at the distributions as a function
of age.</p>
<p>A nice way to compare distributions is to use a <em>violin plot</em></p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>sns.violinplot(&quot;gender&quot;, &quot;split_frac&quot;, data=data, palette=[&quot;lightblue&quot;, &quot;lightpink&quot;]);
</pre></div>
</div>
<img alt="_images/matplotlib_374_0.png" src="_images/matplotlib_374_0.png" />
<p>This is yet another way to compare the distributions between men and
women.</p>
<p>Let’s look a little deeper, and compare these violin plots as a function
of age. We’ll start by creating a new column in the array that specifies
the decade of age that each person is in:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>data[&#39;age_dec&#39;] = data.age.map(lambda age: 10 * (age // 10))
data.head()
</pre></div>
</div>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>age</th>
      <th>gender</th>
      <th>split</th>
      <th>final</th>
      <th>split_sec</th>
      <th>final_sec</th>
      <th>split_frac</th>
      <th>age_dec</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>33</td>
      <td>M</td>
      <td>01:05:38</td>
      <td>02:08:51</td>
      <td>3938.0</td>
      <td>7731.0</td>
      <td>-0.018756</td>
      <td>30</td>
    </tr>
    <tr>
      <th>1</th>
      <td>32</td>
      <td>M</td>
      <td>01:06:26</td>
      <td>02:09:28</td>
      <td>3986.0</td>
      <td>7768.0</td>
      <td>-0.026262</td>
      <td>30</td>
    </tr>
    <tr>
      <th>2</th>
      <td>31</td>
      <td>M</td>
      <td>01:06:49</td>
      <td>02:10:42</td>
      <td>4009.0</td>
      <td>7842.0</td>
      <td>-0.022443</td>
      <td>30</td>
    </tr>
    <tr>
      <th>3</th>
      <td>38</td>
      <td>M</td>
      <td>01:06:16</td>
      <td>02:13:45</td>
      <td>3976.0</td>
      <td>8025.0</td>
      <td>0.009097</td>
      <td>30</td>
    </tr>
    <tr>
      <th>4</th>
      <td>31</td>
      <td>M</td>
      <td>01:06:32</td>
      <td>02:13:59</td>
      <td>3992.0</td>
      <td>8039.0</td>
      <td>0.006842</td>
      <td>30</td>
    </tr>
  </tbody>
</table>
</div><div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>men = (data.gender == &#39;M&#39;)
women = (data.gender == &#39;W&#39;)

with sns.axes_style(style=None):
    sns.violinplot(&quot;age_dec&quot;, &quot;split_frac&quot;, hue=&quot;gender&quot;, data=data,
                   split=True, inner=&quot;quartile&quot;,
                   palette=[&quot;lightblue&quot;, &quot;lightpink&quot;]);
</pre></div>
</div>
<img alt="_images/matplotlib_378_0.png" src="_images/matplotlib_378_0.png" />
<p>Looking at this, we can see where the distributions of men and women
differ: the split distributions of men in their 20s to 50s show a
pronounced over-density toward lower splits when compared to women of
the same age (or of any age, for that matter).</p>
<p>Also surprisingly, the 80-year-old women seem to outperform <em>everyone</em>
in terms of their split time. This is probably due to the fact that
we’re estimating the distribution from small numbers, as there are only
a handful of runners in that range:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>(data.age &gt; 80).sum()
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">7</span>
</pre></div>
</div>
<p>Back to the men with negative splits: who are these runners? Does this
split fraction correlate with finishing quickly? We can plot this very
easily. We’ll use <code class="docutils literal notranslate"><span class="pre">regplot</span></code>, which will automatically fit a linear
regression to the data:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>g = sns.lmplot(&#39;final_sec&#39;, &#39;split_frac&#39;, col=&#39;gender&#39;, data=data,
               markers=&quot;.&quot;, scatter_kws=dict(color=&#39;c&#39;))
g.map(plt.axhline, y=0.1, color=&quot;k&quot;, ls=&quot;:&quot;);
</pre></div>
</div>
<img alt="_images/matplotlib_383_0.png" src="_images/matplotlib_383_0.png" />
</div>
</div>
</div>
</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="pandas.html" title="Previous document">pandas module</a>
        </li>
        <li>
          <a href="networkx.html" title="Next document">networkx module</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2021, Massimo Nocentini.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/matplotlib.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>